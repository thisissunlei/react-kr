'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _simpleAssign = require('simple-assign');

var _simpleAssign2 = _interopRequireDefault(_simpleAssign);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _reactAddonsTransitionGroup = require('react-addons-transition-group');

var _reactAddonsTransitionGroup2 = _interopRequireDefault(_reactAddonsTransitionGroup);

var _dom = require('../utils/dom');

var _dom2 = _interopRequireDefault(_dom);

var _CircleRipple = require('./CircleRipple');

var _CircleRipple2 = _interopRequireDefault(_CircleRipple);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

// Remove the first element of the array
var shift = function shift(_ref) {
  var _ref2 = _toArray(_ref),
      newArray = _ref2.slice(1);

  return newArray;
};

var TouchRipple = function (_Component) {
  _inherits(TouchRipple, _Component);

  function TouchRipple(props, context) {
    _classCallCheck(this, TouchRipple);

    // Touch start produces a mouse down event for compat reasons. To avoid
    // showing ripples twice we skip showing a ripple for the first mouse down
    // after a touch start. Note we don't store ignoreNextMouseDown in this.state
    // to avoid re-rendering when we change it.
    var _this = _possibleConstructorReturn(this, (TouchRipple.__proto__ || Object.getPrototypeOf(TouchRipple)).call(this, props, context));

    _this.handleMouseDown = function (event) {
      // only listen to left clicks
      if (event.button === 0) {
        _this.start(event, false);
      }
    };

    _this.handleMouseUp = function () {
      _this.end();
    };

    _this.handleMouseLeave = function () {
      _this.end();
    };

    _this.handleTouchStart = function (event) {
      event.stopPropagation();
      // If the user is swiping (not just tapping), save the position so we can
      // abort ripples if the user appears to be scrolling.
      if (_this.props.abortOnScroll && event.touches) {
        _this.startListeningForScrollAbort(event);
        _this.startTime = Date.now();
      }
      _this.start(event, true);
    };

    _this.handleTouchEnd = function () {
      _this.end();
    };

    _this.handleTouchMove = function (event) {
      // Stop trying to abort if we're already 300ms into the animation
      var timeSinceStart = Math.abs(Date.now() - _this.startTime);
      if (timeSinceStart > 300) {
        _this.stopListeningForScrollAbort();
        return;
      }

      // If the user is scrolling...
      var deltaY = Math.abs(event.touches[0].clientY - _this.firstTouchY);
      var deltaX = Math.abs(event.touches[0].clientX - _this.firstTouchX);
      // Call it a scroll after an arbitrary 6px (feels reasonable in testing)
      if (deltaY > 6 || deltaX > 6) {
        var currentRipples = _this.state.ripples;
        var ripple = currentRipples[0];
        // This clone will replace the ripple in ReactTransitionGroup with a
        // version that will disappear immediately when removed from the DOM
        var abortedRipple = _react2.default.cloneElement(ripple, { aborted: true });
        // Remove the old ripple and replace it with the new updated one
        currentRipples = shift(currentRipples);
        currentRipples = [].concat(_toConsumableArray(currentRipples), [abortedRipple]);
        _this.setState({ ripples: currentRipples }, function () {
          // Call end after we've set the ripple to abort otherwise the setState
          // in end() merges with this and the ripple abort fails
          _this.end();
        });
      }
    };

    _this.ignoreNextMouseDown = false;

    _this.state = {
      // This prop allows us to only render the ReactTransitionGroup
      // on the first click of the component, making the inital render faster.
      hasRipples: false,
      nextKey: 0,
      ripples: []
    };
    return _this;
  }

  _createClass(TouchRipple, [{
    key: 'start',
    value: function start(event, isRippleTouchGenerated) {
      var theme = this.context.muiTheme.ripple;

      if (this.ignoreNextMouseDown && !isRippleTouchGenerated) {
        this.ignoreNextMouseDown = false;
        return;
      }

      var ripples = this.state.ripples;

      // Add a ripple to the ripples array
      ripples = [].concat(_toConsumableArray(ripples), [_react2.default.createElement(_CircleRipple2.default, {
        key: this.state.nextKey,
        style: !this.props.centerRipple ? this.getRippleStyle(event) : {},
        color: this.props.color || theme.color,
        opacity: this.props.opacity,
        touchGenerated: isRippleTouchGenerated
      })]);

      this.ignoreNextMouseDown = isRippleTouchGenerated;
      this.setState({
        hasRipples: true,
        nextKey: this.state.nextKey + 1,
        ripples: ripples
      });
    }
  }, {
    key: 'end',
    value: function end() {
      var currentRipples = this.state.ripples;
      this.setState({
        ripples: shift(currentRipples)
      });
      if (this.props.abortOnScroll) {
        this.stopListeningForScrollAbort();
      }
    }

    // Check if the user seems to be scrolling and abort the animation if so

  }, {
    key: 'startListeningForScrollAbort',
    value: function startListeningForScrollAbort(event) {
      this.firstTouchY = event.touches[0].clientY;
      this.firstTouchX = event.touches[0].clientX;
      // Note that when scolling Chrome throttles this event to every 200ms
      // Also note we don't listen for scroll events directly as there's no general
      // way to cover cases like scrolling within containers on the page
      document.body.addEventListener('touchmove', this.handleTouchMove);
    }
  }, {
    key: 'stopListeningForScrollAbort',
    value: function stopListeningForScrollAbort() {
      document.body.removeEventListener('touchmove', this.handleTouchMove);
    }
  }, {
    key: 'getRippleStyle',
    value: function getRippleStyle(event) {
      var el = _reactDom2.default.findDOMNode(this);
      var elHeight = el.offsetHeight;
      var elWidth = el.offsetWidth;
      var offset = _dom2.default.offset(el);
      var isTouchEvent = event.touches && event.touches.length;
      var pageX = isTouchEvent ? event.touches[0].pageX : event.pageX;
      var pageY = isTouchEvent ? event.touches[0].pageY : event.pageY;
      var pointerX = pageX - offset.left;
      var pointerY = pageY - offset.top;
      var topLeftDiag = this.calcDiag(pointerX, pointerY);
      var topRightDiag = this.calcDiag(elWidth - pointerX, pointerY);
      var botRightDiag = this.calcDiag(elWidth - pointerX, elHeight - pointerY);
      var botLeftDiag = this.calcDiag(pointerX, elHeight - pointerY);
      var rippleRadius = Math.max(topLeftDiag, topRightDiag, botRightDiag, botLeftDiag);
      var rippleSize = rippleRadius * 2;
      var left = pointerX - rippleRadius;
      var top = pointerY - rippleRadius;

      return {
        directionInvariant: true,
        height: rippleSize,
        width: rippleSize,
        top: top,
        left: left
      };
    }
  }, {
    key: 'calcDiag',
    value: function calcDiag(a, b) {
      return Math.sqrt(a * a + b * b);
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          children = _props.children,
          style = _props.style;
      var _state = this.state,
          hasRipples = _state.hasRipples,
          ripples = _state.ripples;
      var prepareStyles = this.context.muiTheme.prepareStyles;


      var rippleGroup = void 0;

      if (hasRipples) {
        var mergedStyles = (0, _simpleAssign2.default)({
          height: '100%',
          width: '100%',
          position: 'absolute',
          top: 0,
          left: 0,
          overflow: 'hidden'
        }, style);

        rippleGroup = _react2.default.createElement(
          _reactAddonsTransitionGroup2.default,
          { style: prepareStyles(mergedStyles) },
          ripples
        );
      }

      return _react2.default.createElement(
        'div',
        {
          onMouseUp: this.handleMouseUp,
          onMouseDown: this.handleMouseDown,
          onMouseLeave: this.handleMouseLeave,
          onTouchStart: this.handleTouchStart,
          onTouchEnd: this.handleTouchEnd
        },
        rippleGroup,
        children
      );
    }
  }]);

  return TouchRipple;
}(_react.Component);

TouchRipple.propTypes = {
  abortOnScroll: _react.PropTypes.bool,
  centerRipple: _react.PropTypes.bool,
  children: _react.PropTypes.node,
  color: _react.PropTypes.string,
  opacity: _react.PropTypes.number,
  style: _react.PropTypes.object
};
TouchRipple.defaultProps = {
  abortOnScroll: true
};
TouchRipple.contextTypes = {
  muiTheme: _react.PropTypes.object.isRequired
};
var _default = TouchRipple;
exports.default = _default;
;

var _temp = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(shift, 'shift', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/internal/TouchRipple.js');

  __REACT_HOT_LOADER__.register(TouchRipple, 'TouchRipple', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/internal/TouchRipple.js');

  __REACT_HOT_LOADER__.register(_default, 'default', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/internal/TouchRipple.js');
}();

;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9Db21wb25lbnRzL0RhdGVQaWNrZXIvaW50ZXJuYWwvVG91Y2hSaXBwbGUuanMiXSwibmFtZXMiOlsic2hpZnQiLCJuZXdBcnJheSIsIlRvdWNoUmlwcGxlIiwicHJvcHMiLCJjb250ZXh0IiwiaGFuZGxlTW91c2VEb3duIiwiZXZlbnQiLCJidXR0b24iLCJzdGFydCIsImhhbmRsZU1vdXNlVXAiLCJlbmQiLCJoYW5kbGVNb3VzZUxlYXZlIiwiaGFuZGxlVG91Y2hTdGFydCIsInN0b3BQcm9wYWdhdGlvbiIsImFib3J0T25TY3JvbGwiLCJ0b3VjaGVzIiwic3RhcnRMaXN0ZW5pbmdGb3JTY3JvbGxBYm9ydCIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJoYW5kbGVUb3VjaEVuZCIsImhhbmRsZVRvdWNoTW92ZSIsInRpbWVTaW5jZVN0YXJ0IiwiTWF0aCIsImFicyIsInN0b3BMaXN0ZW5pbmdGb3JTY3JvbGxBYm9ydCIsImRlbHRhWSIsImNsaWVudFkiLCJmaXJzdFRvdWNoWSIsImRlbHRhWCIsImNsaWVudFgiLCJmaXJzdFRvdWNoWCIsImN1cnJlbnRSaXBwbGVzIiwic3RhdGUiLCJyaXBwbGVzIiwicmlwcGxlIiwiYWJvcnRlZFJpcHBsZSIsImNsb25lRWxlbWVudCIsImFib3J0ZWQiLCJzZXRTdGF0ZSIsImlnbm9yZU5leHRNb3VzZURvd24iLCJoYXNSaXBwbGVzIiwibmV4dEtleSIsImlzUmlwcGxlVG91Y2hHZW5lcmF0ZWQiLCJ0aGVtZSIsIm11aVRoZW1lIiwiY2VudGVyUmlwcGxlIiwiZ2V0UmlwcGxlU3R5bGUiLCJjb2xvciIsIm9wYWNpdHkiLCJkb2N1bWVudCIsImJvZHkiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImVsIiwiZmluZERPTU5vZGUiLCJlbEhlaWdodCIsIm9mZnNldEhlaWdodCIsImVsV2lkdGgiLCJvZmZzZXRXaWR0aCIsIm9mZnNldCIsImlzVG91Y2hFdmVudCIsImxlbmd0aCIsInBhZ2VYIiwicGFnZVkiLCJwb2ludGVyWCIsImxlZnQiLCJwb2ludGVyWSIsInRvcCIsInRvcExlZnREaWFnIiwiY2FsY0RpYWciLCJ0b3BSaWdodERpYWciLCJib3RSaWdodERpYWciLCJib3RMZWZ0RGlhZyIsInJpcHBsZVJhZGl1cyIsIm1heCIsInJpcHBsZVNpemUiLCJkaXJlY3Rpb25JbnZhcmlhbnQiLCJoZWlnaHQiLCJ3aWR0aCIsImEiLCJiIiwic3FydCIsImNoaWxkcmVuIiwic3R5bGUiLCJwcmVwYXJlU3R5bGVzIiwicmlwcGxlR3JvdXAiLCJtZXJnZWRTdHlsZXMiLCJwb3NpdGlvbiIsIm92ZXJmbG93IiwicHJvcFR5cGVzIiwiYm9vbCIsIm5vZGUiLCJzdHJpbmciLCJudW1iZXIiLCJvYmplY3QiLCJkZWZhdWx0UHJvcHMiLCJjb250ZXh0VHlwZXMiLCJpc1JlcXVpcmVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7QUFDQSxJQUFNQSxRQUFRLFNBQVJBLEtBQVE7QUFBQTtBQUFBLE1BQU9DLFFBQVA7O0FBQUEsU0FBcUJBLFFBQXJCO0FBQUEsQ0FBZDs7SUFFTUMsVzs7O0FBa0JKLHVCQUFZQyxLQUFaLEVBQW1CQyxPQUFuQixFQUE0QjtBQUFBOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUwwQiwwSEFDcEJELEtBRG9CLEVBQ2JDLE9BRGE7O0FBQUEsVUF3RDVCQyxlQXhENEIsR0F3RFYsVUFBQ0MsS0FBRCxFQUFXO0FBQzNCO0FBQ0EsVUFBSUEsTUFBTUMsTUFBTixLQUFpQixDQUFyQixFQUF3QjtBQUN0QixjQUFLQyxLQUFMLENBQVdGLEtBQVgsRUFBa0IsS0FBbEI7QUFDRDtBQUNGLEtBN0QyQjs7QUFBQSxVQStENUJHLGFBL0Q0QixHQStEWixZQUFNO0FBQ3BCLFlBQUtDLEdBQUw7QUFDRCxLQWpFMkI7O0FBQUEsVUFtRTVCQyxnQkFuRTRCLEdBbUVULFlBQU07QUFDdkIsWUFB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QUFheUMsUUFIOUIsQ0FHQXdDLGFBSEE7OztBQUtQLFVBQUlDLG9CQUFKOztBQUVBLFVBQUk3QyxVQUFKLEVBQWdCO0FBQ2QsWUFBTThDLGVBQWUsNEJBQWM7QUFDakNULGtCQUFRLE1BRHlCO0FBRWpDQyxpQkFBTyxNQUYwQjtBQUdqQ1Msb0JBQVUsVUFIdUI7QUFJakNwQixlQUFLLENBSjRCO0FBS2pDRixnQkFBTSxDQUwyQjtBQU1qQ3VCLG9CQUFVO0FBTnVCLFNBQWQsRUFPbEJMLEtBUGtCLENBQXJCOztBQVNBRSxzQkFDRTtBQUFBO0FBQUEsWUFBc0IsT0FBT0QsY0FBY0UsWUFBZCxDQUE3QjtBQUNHckQ7QUFESCxTQURGO0FBS0Q7O0FBRUQsYUFDRTtBQUFBO0FBQUE7QUFDRSxxQkFBVyxLQUFLekIsYUFEbEI7QUFFRSx1QkFBYSxLQUFLSixlQUZwQjtBQUdFLHdCQUFjLEtBQUtNLGdCQUhyQjtBQUlFLHdCQUFjLEtBQUtDLGdCQUpyQjtBQUtFLHNCQUFZLEtBQUtRO0FBTG5CO0FBT0drRSxtQkFQSDtBQVFHSDtBQVJILE9BREY7QUFZRDs7Ozs7O0FBek5HakYsVyxDQUNHd0YsUyxHQUFZO0FBQ2pCNUUsaUJBQWUsaUJBQVU2RSxJQURSO0FBRWpCN0MsZ0JBQWMsaUJBQVU2QyxJQUZQO0FBR2pCUixZQUFVLGlCQUFVUyxJQUhIO0FBSWpCNUMsU0FBTyxpQkFBVTZDLE1BSkE7QUFLakI1QyxXQUFTLGlCQUFVNkMsTUFMRjtBQU1qQlYsU0FBTyxpQkFBVVc7QUFOQSxDO0FBRGY3RixXLENBVUc4RixZLEdBQWU7QUFDcEJsRixpQkFBZTtBQURLLEM7QUFWbEJaLFcsQ0FjRytGLFksR0FBZTtBQUNwQnBELFlBQVUsaUJBQVVrRCxNQUFWLENBQWlCRztBQURQLEM7ZUE4TVRoRyxXOzs7Ozs7Ozs7Z0NBOU5URixLOztnQ0FFQUUsVyIsImZpbGUiOiJUb3VjaFJpcHBsZS5qcyIsInNvdXJjZVJvb3QiOiIvVXNlcnMvdG1hY196Yy9Db2RlL2tyLWFkbWluIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50LCBQcm9wVHlwZXN9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFJlYWN0VHJhbnNpdGlvbkdyb3VwIGZyb20gJ3JlYWN0LWFkZG9ucy10cmFuc2l0aW9uLWdyb3VwJztcbmltcG9ydCBEb20gZnJvbSAnLi4vdXRpbHMvZG9tJztcbmltcG9ydCBDaXJjbGVSaXBwbGUgZnJvbSAnLi9DaXJjbGVSaXBwbGUnO1xuXG4vLyBSZW1vdmUgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGFycmF5XG5jb25zdCBzaGlmdCA9IChbLCAuLi5uZXdBcnJheV0pID0+IG5ld0FycmF5O1xuXG5jbGFzcyBUb3VjaFJpcHBsZSBleHRlbmRzIENvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgYWJvcnRPblNjcm9sbDogUHJvcFR5cGVzLmJvb2wsXG4gICAgY2VudGVyUmlwcGxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgY29sb3I6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgb3BhY2l0eTogUHJvcFR5cGVzLm51bWJlcixcbiAgICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGFib3J0T25TY3JvbGw6IHRydWUsXG4gIH07XG5cbiAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICBtdWlUaGVtZTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgc3VwZXIocHJvcHMsIGNvbnRleHQpO1xuICAgIC8vIFRvdWNoIHN0YXJ0IHByb2R1Y2VzIGEgbW91c2UgZG93biBldmVudCBmb3IgY29tcGF0IHJlYXNvbnMuIFRvIGF2b2lkXG4gICAgLy8gc2hvd2luZyByaXBwbGVzIHR3aWNlIHdlIHNraXAgc2hvd2luZyBhIHJpcHBsZSBmb3IgdGhlIGZpcnN0IG1vdXNlIGRvd25cbiAgICAvLyBhZnRlciBhIHRvdWNoIHN0YXJ0LiBOb3RlIHdlIGRvbid0IHN0b3JlIGlnbm9yZU5leHRNb3VzZURvd24gaW4gdGhpcy5zdGF0ZVxuICAgIC8vIHRvIGF2b2lkIHJlLXJlbmRlcmluZyB3aGVuIHdlIGNoYW5nZSBpdC5cbiAgICB0aGlzLmlnbm9yZU5leHRNb3VzZURvd24gPSBmYWxzZTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAvLyBUaGlzIHByb3AgYWxsb3dzIHVzIHRvIG9ubHkgcmVuZGVyIHRoZSBSZWFjdFRyYW5zaXRpb25Hcm91cFxuICAgICAgLy8gb24gdGhlIGZpcnN0IGNsaWNrIG9mIHRoZSBjb21wb25lbnQsIG1ha2luZyB0aGUgaW5pdGFsIHJlbmRlciBmYXN0ZXIuXG4gICAgICBoYXNSaXBwbGVzOiBmYWxzZSxcbiAgICAgIG5leHRLZXk6IDAsXG4gICAgICByaXBwbGVzOiBbXSxcbiAgICB9O1xuICB9XG5cbiAgc3RhcnQoZXZlbnQsIGlzUmlwcGxlVG91Y2hHZW5lcmF0ZWQpIHtcbiAgICBjb25zdCB0aGVtZSA9IHRoaXMuY29udGV4dC5tdWlUaGVtZS5yaXBwbGU7XG5cbiAgICBpZiAodGhpcy5pZ25vcmVOZXh0TW91c2VEb3duICYmICFpc1JpcHBsZVRvdWNoR2VuZXJhdGVkKSB7XG4gICAgICB0aGlzLmlnbm9yZU5leHRNb3VzZURvd24gPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgcmlwcGxlcyA9IHRoaXMuc3RhdGUucmlwcGxlcztcblxuICAgIC8vIEFkZCBhIHJpcHBsZSB0byB0aGUgcmlwcGxlcyBhcnJheVxuICAgIHJpcHBsZXMgPSBbLi4ucmlwcGxlcywgKFxuICAgICAgPENpcmNsZVJpcHBsZVxuICAgICAgICBrZXk9e3RoaXMuc3RhdGUubmV4dEtleX1cbiAgICAgICAgc3R5bGU9eyF0aGlzLnByb3BzLmNlbnRlclJpcHBsZSA/IHRoaXMuZ2V0UmlwcGxlU3R5bGUoZXZlbnQpIDoge319XG4gICAgICAgIGNvbG9yPXt0aGlzLnByb3BzLmNvbG9yIHx8IHRoZW1lLmNvbG9yfVxuICAgICAgICBvcGFjaXR5PXt0aGlzLnByb3BzLm9wYWNpdHl9XG4gICAgICAgIHRvdWNoR2VuZXJhdGVkPXtpc1JpcHBsZVRvdWNoR2VuZXJhdGVkfVxuICAgICAgLz5cbiAgICApXTtcblxuICAgIHRoaXMuaWdub3JlTmV4dE1vdXNlRG93biA9IGlzUmlwcGxlVG91Y2hHZW5lcmF0ZWQ7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBoYXNSaXBwbGVzOiB0cnVlLFxuICAgICAgbmV4dEtleTogdGhpcy5zdGF0ZS5uZXh0S2V5ICsgMSxcbiAgICAgIHJpcHBsZXM6IHJpcHBsZXMsXG4gICAgfSk7XG4gIH1cblxuICBlbmQoKSB7XG4gICAgY29uc3QgY3VycmVudFJpcHBsZXMgPSB0aGlzLnN0YXRlLnJpcHBsZXM7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICByaXBwbGVzOiBzaGlmdChjdXJyZW50UmlwcGxlcyksXG4gICAgfSk7XG4gICAgaWYgKHRoaXMucHJvcHMuYWJvcnRPblNjcm9sbCkge1xuICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nRm9yU2Nyb2xsQWJvcnQoKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVNb3VzZURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAvLyBvbmx5IGxpc3RlbiB0byBsZWZ0IGNsaWNrc1xuICAgIGlmIChldmVudC5idXR0b24gPT09IDApIHtcbiAgICAgIHRoaXMuc3RhcnQoZXZlbnQsIGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlTW91c2VVcCA9ICgpID0+IHtcbiAgICB0aGlzLmVuZCgpO1xuICB9O1xuXG4gIGhhbmRsZU1vdXNlTGVhdmUgPSAoKSA9PiB7XG4gICAgdGhpcy5lbmQoKTtcbiAgfTtcblxuICBoYW5kbGVUb3VjaFN0YXJ0ID0gKGV2ZW50KSA9PiB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgLy8gSWYgdGhlIHVzZXIgaXMgc3dpcGluZyAobm90IGp1c3QgdGFwcGluZyksIHNhdmUgdGhlIHBvc2l0aW9uIHNvIHdlIGNhblxuICAgIC8vIGFib3J0IHJpcHBsZXMgaWYgdGhlIHVzZXIgYXBwZWFycyB0byBiZSBzY3JvbGxpbmcuXG4gICAgaWYgKHRoaXMucHJvcHMuYWJvcnRPblNjcm9sbCAmJiBldmVudC50b3VjaGVzKSB7XG4gICAgICB0aGlzLnN0YXJ0TGlzdGVuaW5nRm9yU2Nyb2xsQWJvcnQoZXZlbnQpO1xuICAgICAgdGhpcy5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIH1cbiAgICB0aGlzLnN0YXJ0KGV2ZW50LCB0cnVlKTtcbiAgfTtcblxuICBoYW5kbGVUb3VjaEVuZCA9ICgpID0+IHtcbiAgICB0aGlzLmVuZCgpO1xuICB9O1xuXG4gIC8vIENoZWNrIGlmIHRoZSB1c2VyIHNlZW1zIHRvIGJlIHNjcm9sbGluZyBhbmQgYWJvcnQgdGhlIGFuaW1hdGlvbiBpZiBzb1xuICBoYW5kbGVUb3VjaE1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICAvLyBTdG9wIHRyeWluZyB0byBhYm9ydCBpZiB3ZSdyZSBhbHJlYWR5IDMwMG1zIGludG8gdGhlIGFuaW1hdGlvblxuICAgIGNvbnN0IHRpbWVTaW5jZVN0YXJ0ID0gTWF0aC5hYnMoRGF0ZS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lKTtcbiAgICBpZiAodGltZVNpbmNlU3RhcnQgPiAzMDApIHtcbiAgICAgIHRoaXMuc3RvcExpc3RlbmluZ0ZvclNjcm9sbEFib3J0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVzZXIgaXMgc2Nyb2xsaW5nLi4uXG4gICAgY29uc3QgZGVsdGFZID0gTWF0aC5hYnMoZXZlbnQudG91Y2hlc1swXS5jbGllbnRZIC0gdGhpcy5maXJzdFRvdWNoWSk7XG4gICAgY29uc3QgZGVsdGFYID0gTWF0aC5hYnMoZXZlbnQudG91Y2hlc1swXS5jbGllbnRYIC0gdGhpcy5maXJzdFRvdWNoWCk7XG4gICAgLy8gQ2FsbCBpdCBhIHNjcm9sbCBhZnRlciBhbiBhcmJpdHJhcnkgNnB4IChmZWVscyByZWFzb25hYmxlIGluIHRlc3RpbmcpXG4gICAgaWYgKGRlbHRhWSA+IDYgfHwgZGVsdGFYID4gNikge1xuICAgICAgbGV0IGN1cnJlbnRSaXBwbGVzID0gdGhpcy5zdGF0ZS5yaXBwbGVzO1xuICAgICAgY29uc3QgcmlwcGxlID0gY3VycmVudFJpcHBsZXNbMF07XG4gICAgICAvLyBUaGlzIGNsb25lIHdpbGwgcmVwbGFjZSB0aGUgcmlwcGxlIGluIFJlYWN0VHJhbnNpdGlvbkdyb3VwIHdpdGggYVxuICAgICAgLy8gdmVyc2lvbiB0aGF0IHdpbGwgZGlzYXBwZWFyIGltbWVkaWF0ZWx5IHdoZW4gcmVtb3ZlZCBmcm9tIHRoZSBET01cbiAgICAgIGNvbnN0IGFib3J0ZWRSaXBwbGUgPSBSZWFjdC5jbG9uZUVsZW1lbnQocmlwcGxlLCB7YWJvcnRlZDogdHJ1ZX0pO1xuICAgICAgLy8gUmVtb3ZlIHRoZSBvbGQgcmlwcGxlIGFuZCByZXBsYWNlIGl0IHdpdGggdGhlIG5ldyB1cGRhdGVkIG9uZVxuICAgICAgY3VycmVudFJpcHBsZXMgPSBzaGlmdChjdXJyZW50UmlwcGxlcyk7XG4gICAgICBjdXJyZW50UmlwcGxlcyA9IFsuLi5jdXJyZW50UmlwcGxlcywgYWJvcnRlZFJpcHBsZV07XG4gICAgICB0aGlzLnNldFN0YXRlKHtyaXBwbGVzOiBjdXJyZW50UmlwcGxlc30sICgpID0+IHtcbiAgICAgICAgLy8gQ2FsbCBlbmQgYWZ0ZXIgd2UndmUgc2V0IHRoZSByaXBwbGUgdG8gYWJvcnQgb3RoZXJ3aXNlIHRoZSBzZXRTdGF0ZVxuICAgICAgICAvLyBpbiBlbmQoKSBtZXJnZXMgd2l0aCB0aGlzIGFuZCB0aGUgcmlwcGxlIGFib3J0IGZhaWxzXG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgc3RhcnRMaXN0ZW5pbmdGb3JTY3JvbGxBYm9ydChldmVudCkge1xuICAgIHRoaXMuZmlyc3RUb3VjaFkgPSBldmVudC50b3VjaGVzWzBdLmNsaWVudFk7XG4gICAgdGhpcy5maXJzdFRvdWNoWCA9IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAvLyBOb3RlIHRoYXQgd2hlbiBzY29sbGluZyBDaHJvbWUgdGhyb3R0bGVzIHRoaXMgZXZlbnQgdG8gZXZlcnkgMjAwbXNcbiAgICAvLyBBbHNvIG5vdGUgd2UgZG9uJ3QgbGlzdGVuIGZvciBzY3JvbGwgZXZlbnRzIGRpcmVjdGx5IGFzIHRoZXJlJ3Mgbm8gZ2VuZXJhbFxuICAgIC8vIHdheSB0byBjb3ZlciBjYXNlcyBsaWtlIHNjcm9sbGluZyB3aXRoaW4gY29udGFpbmVycyBvbiB0aGUgcGFnZVxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUb3VjaE1vdmUpO1xuICB9XG5cbiAgc3RvcExpc3RlbmluZ0ZvclNjcm9sbEFib3J0KCkge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUb3VjaE1vdmUpO1xuICB9XG5cbiAgZ2V0UmlwcGxlU3R5bGUoZXZlbnQpIHtcbiAgICBjb25zdCBlbCA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuICAgIGNvbnN0IGVsSGVpZ2h0ID0gZWwub2Zmc2V0SGVpZ2h0O1xuICAgIGNvbnN0IGVsV2lkdGggPSBlbC5vZmZzZXRXaWR0aDtcbiAgICBjb25zdCBvZmZzZXQgPSBEb20ub2Zmc2V0KGVsKTtcbiAgICBjb25zdCBpc1RvdWNoRXZlbnQgPSBldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoO1xuICAgIGNvbnN0IHBhZ2VYID0gaXNUb3VjaEV2ZW50ID8gZXZlbnQudG91Y2hlc1swXS5wYWdlWCA6IGV2ZW50LnBhZ2VYO1xuICAgIGNvbnN0IHBhZ2VZID0gaXNUb3VjaEV2ZW50ID8gZXZlbnQudG91Y2hlc1swXS5wYWdlWSA6IGV2ZW50LnBhZ2VZO1xuICAgIGNvbnN0IHBvaW50ZXJYID0gcGFnZVggLSBvZmZzZXQubGVmdDtcbiAgICBjb25zdCBwb2ludGVyWSA9IHBhZ2VZIC0gb2Zmc2V0LnRvcDtcbiAgICBjb25zdCB0b3BMZWZ0RGlhZyA9IHRoaXMuY2FsY0RpYWcocG9pbnRlclgsIHBvaW50ZXJZKTtcbiAgICBjb25zdCB0b3BSaWdodERpYWcgPSB0aGlzLmNhbGNEaWFnKGVsV2lkdGggLSBwb2ludGVyWCwgcG9pbnRlclkpO1xuICAgIGNvbnN0IGJvdFJpZ2h0RGlhZyA9IHRoaXMuY2FsY0RpYWcoZWxXaWR0aCAtIHBvaW50ZXJYLCBlbEhlaWdodCAtIHBvaW50ZXJZKTtcbiAgICBjb25zdCBib3RMZWZ0RGlhZyA9IHRoaXMuY2FsY0RpYWcocG9pbnRlclgsIGVsSGVpZ2h0IC0gcG9pbnRlclkpO1xuICAgIGNvbnN0IHJpcHBsZVJhZGl1cyA9IE1hdGgubWF4KFxuICAgICAgdG9wTGVmdERpYWcsIHRvcFJpZ2h0RGlhZywgYm90UmlnaHREaWFnLCBib3RMZWZ0RGlhZ1xuICAgICk7XG4gICAgY29uc3QgcmlwcGxlU2l6ZSA9IHJpcHBsZVJhZGl1cyAqIDI7XG4gICAgY29uc3QgbGVmdCA9IHBvaW50ZXJYIC0gcmlwcGxlUmFkaXVzO1xuICAgIGNvbnN0IHRvcCA9IHBvaW50ZXJZIC0gcmlwcGxlUmFkaXVzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpcmVjdGlvbkludmFyaWFudDogdHJ1ZSxcbiAgICAgIGhlaWdodDogcmlwcGxlU2l6ZSxcbiAgICAgIHdpZHRoOiByaXBwbGVTaXplLFxuICAgICAgdG9wOiB0b3AsXG4gICAgICBsZWZ0OiBsZWZ0LFxuICAgIH07XG4gIH1cblxuICBjYWxjRGlhZyhhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgoYSAqIGEpICsgKGIgKiBiKSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge2NoaWxkcmVuLCBzdHlsZX0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtoYXNSaXBwbGVzLCByaXBwbGVzfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qge3ByZXBhcmVTdHlsZXN9ID0gdGhpcy5jb250ZXh0Lm11aVRoZW1lO1xuXG4gICAgbGV0IHJpcHBsZUdyb3VwO1xuXG4gICAgaWYgKGhhc1JpcHBsZXMpIHtcbiAgICAgIGNvbnN0IG1lcmdlZFN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgfSwgc3R5bGUpO1xuXG4gICAgICByaXBwbGVHcm91cCA9IChcbiAgICAgICAgPFJlYWN0VHJhbnNpdGlvbkdyb3VwIHN0eWxlPXtwcmVwYXJlU3R5bGVzKG1lcmdlZFN0eWxlcyl9PlxuICAgICAgICAgIHtyaXBwbGVzfVxuICAgICAgICA8L1JlYWN0VHJhbnNpdGlvbkdyb3VwPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICBvbk1vdXNlVXA9e3RoaXMuaGFuZGxlTW91c2VVcH1cbiAgICAgICAgb25Nb3VzZURvd249e3RoaXMuaGFuZGxlTW91c2VEb3dufVxuICAgICAgICBvbk1vdXNlTGVhdmU9e3RoaXMuaGFuZGxlTW91c2VMZWF2ZX1cbiAgICAgICAgb25Ub3VjaFN0YXJ0PXt0aGlzLmhhbmRsZVRvdWNoU3RhcnR9XG4gICAgICAgIG9uVG91Y2hFbmQ9e3RoaXMuaGFuZGxlVG91Y2hFbmR9XG4gICAgICA+XG4gICAgICAgIHtyaXBwbGVHcm91cH1cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUb3VjaFJpcHBsZTtcbiJdfQ==