'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _simpleAssign = require('simple-assign');

var _simpleAssign2 = _interopRequireDefault(_simpleAssign);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactEventListener = require('react-event-listener');

var _reactEventListener2 = _interopRequireDefault(_reactEventListener);

var _keycode = require('keycode');

var _keycode2 = _interopRequireDefault(_keycode);

var _Calendar = require('./Calendar');

var _Calendar2 = _interopRequireDefault(_Calendar);

var _Dialog = require('../Dialog');

var _Dialog2 = _interopRequireDefault(_Dialog);

var _Popover = require('../Popover/Popover');

var _Popover2 = _interopRequireDefault(_Popover);

var _PopoverAnimationVertical = require('../Popover/PopoverAnimationVertical');

var _PopoverAnimationVertical2 = _interopRequireDefault(_PopoverAnimationVertical);

var _dateUtils = require('./dateUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DatePickerDialog = function (_Component) {
  _inherits(DatePickerDialog, _Component);

  function DatePickerDialog() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, DatePickerDialog);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = DatePickerDialog.__proto__ || Object.getPrototypeOf(DatePickerDialog)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      open: false
    }, _this.show = function () {
      if (_this.props.onShow && !_this.state.open) {
        _this.props.onShow();
      }

      _this.setState({
        open: true
      });
    }, _this.dismiss = function () {
      if (_this.props.onDismiss && _this.state.open) {
        _this.props.onDismiss();
      }

      _this.setState({
        open: false
      });
    }, _this.handleTouchTapDay = function () {
      if (_this.props.autoOk) {
        setTimeout(_this.handleTouchTapOk, 0);
      }
    }, _this.handleTouchTapCancel = function () {
      _this.dismiss();
    }, _this.handleRequestClose = function () {
      _this.dismiss();
    }, _this.handleTouchTapOk = function () {
      if (_this.props.onAccept && !_this.refs.calendar.isSelectedDateDisabled()) {

        _this.props.onAccept(_this.refs.calendar.getSelectedDate());
      }

      _this.setState({
        open: false
      });
    }, _this.handleWindowKeyUp = function (event) {
      switch ((0, _keycode2.default)(event)) {
        case 'enter':
          _this.handleTouchTapOk();
          break;
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(DatePickerDialog, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          DateTimeFormat = _props.DateTimeFormat,
          autoOk = _props.autoOk,
          cancelLabel = _props.cancelLabel,
          container = _props.container,
          containerStyle = _props.containerStyle,
          disableYearSelection = _props.disableYearSelection,
          initialDate = _props.initialDate,
          firstDayOfWeek = _props.firstDayOfWeek,
          locale = _props.locale,
          maxDate = _props.maxDate,
          minDate = _props.minDate,
          mode = _props.mode,
          okLabel = _props.okLabel,
          onAccept = _props.onAccept,
          onDismiss = _props.onDismiss,
          onShow = _props.onShow,
          shouldDisableDate = _props.shouldDisableDate,
          style = _props.style,
          animation = _props.animation,
          other = _objectWithoutProperties(_props, ['DateTimeFormat', 'autoOk', 'cancelLabel', 'container', 'containerStyle', 'disableYearSelection', 'initialDate', 'firstDayOfWeek', 'locale', 'maxDate', 'minDate', 'mode', 'okLabel', 'onAccept', 'onDismiss', 'onShow', 'shouldDisableDate', 'style', 'animation']);

      var open = this.state.open;


      var styles = {
        dialogContent: {
          width: mode === 'landscape' ? 479 : 310
        },
        dialogBodyContent: {
          padding: 0,
          //minHeight: mode === 'landscape' ? 330 : 434,
          minHeight: mode === 'landscape' ? 330 : 310,
          minWidth: mode === 'landscape' ? 479 : 310
        }
      };

      var Container = container === 'inline' ? _Popover2.default : _Dialog2.default;

      return _react2.default.createElement(
        'div',
        _extends({}, other, { ref: 'root' }),
        _react2.default.createElement(
          Container,
          {
            anchorEl: this.refs.root // For Popover
            , animation: animation || _PopoverAnimationVertical2.default // For Popover
            , bodyStyle: styles.dialogBodyContent,
            contentStyle: styles.dialogContent,
            ref: 'dialog',
            repositionOnUpdate: true,
            open: open,
            onRequestClose: this.handleRequestClose,
            style: (0, _simpleAssign2.default)(styles.dialogBodyContent, containerStyle)
          },
          _react2.default.createElement(_reactEventListener2.default, {
            target: 'window',
            onKeyUp: this.handleWindowKeyUp
          }),
          _react2.default.createElement(_Calendar2.default, {
            autoOk: autoOk,
            DateTimeFormat: DateTimeFormat,
            cancelLabel: cancelLabel,
            disableYearSelection: disableYearSelection,
            firstDayOfWeek: firstDayOfWeek,
            initialDate: initialDate,
            locale: locale,
            onTouchTapDay: this.handleTouchTapDay,
            maxDate: maxDate,
            minDate: minDate,
            mode: mode,
            open: open,
            ref: 'calendar',
            onTouchTapCancel: this.handleTouchTapCancel,
            onTouchTapOk: this.handleTouchTapOk,
            okLabel: okLabel,
            shouldDisableDate: shouldDisableDate
          })
        )
      );
    }
  }]);

  return DatePickerDialog;
}(_react.Component);

DatePickerDialog.propTypes = {
  DateTimeFormat: _react.PropTypes.func,
  animation: _react.PropTypes.func,
  autoOk: _react.PropTypes.bool,
  cancelLabel: _react.PropTypes.node,
  container: _react.PropTypes.oneOf(['dialog', 'inline']),
  containerStyle: _react.PropTypes.object,
  disableYearSelection: _react.PropTypes.bool,
  firstDayOfWeek: _react.PropTypes.number,
  initialDate: _react.PropTypes.object,
  locale: _react.PropTypes.string,
  maxDate: _react.PropTypes.object,
  minDate: _react.PropTypes.object,
  mode: _react.PropTypes.oneOf(['portrait', 'landscape']),
  okLabel: _react.PropTypes.node,
  onAccept: _react.PropTypes.func,
  onDismiss: _react.PropTypes.func,
  onShow: _react.PropTypes.func,
  open: _react.PropTypes.bool,
  shouldDisableDate: _react.PropTypes.func,
  style: _react.PropTypes.object
};
DatePickerDialog.defaultProps = {
  DateTimeFormat: _dateUtils.dateTimeFormat,
  cancelLabel: 'Cancel',
  container: 'dialog',
  locale: 'en-US',
  okLabel: 'OK'
};
DatePickerDialog.contextTypes = {
  muiTheme: _react.PropTypes.object.isRequired
};
var _default = DatePickerDialog;
exports.default = _default;
;

var _temp2 = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(DatePickerDialog, 'DatePickerDialog', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/DatePicker/DatePickerDialog.js');

  __REACT_HOT_LOADER__.register(_default, 'default', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/DatePicker/DatePickerDialog.js');
}();

;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9Db21wb25lbnRzL0RhdGVQaWNrZXIvRGF0ZVBpY2tlci9EYXRlUGlja2VyRGlhbG9nLmpzIl0sIm5hbWVzIjpbIkRhdGVQaWNrZXJEaWFsb2ciLCJzdGF0ZSIsIm9wZW4iLCJzaG93IiwicHJvcHMiLCJvblNob3ciLCJzZXRTdGF0ZSIsImRpc21pc3MiLCJvbkRpc21pc3MiLCJoYW5kbGVUb3VjaFRhcERheSIsImF1dG9PayIsInNldFRpbWVvdXQiLCJoYW5kbGVUb3VjaFRhcE9rIiwiaGFuZGxlVG91Y2hUYXBDYW5jZWwiLCJoYW5kbGVSZXF1ZXN0Q2xvc2UiLCJvbkFjY2VwdCIsInJlZnMiLCJjYWxlbmRhciIsImlzU2VsZWN0ZWREYXRlRGlzYWJsZWQiLCJnZXRTZWxlY3RlZERhdGUiLCJoYW5kbGVXaW5kb3dLZXlVcCIsImV2ZW50IiwiRGF0ZVRpbWVGb3JtYXQiLCJjYW5jZWxMYWJlbCIsImNvbnRhaW5lciIsImNvbnRhaW5lclN0eWxlIiwiZGlzYWJsZVllYXJTZWxlY3Rpb24iLCJpbml0aWFsRGF0ZSIsImZpcnN0RGF5T2ZXZWVrIiwibG9jYWxlIiwibWF4RGF0ZSIsIm1pbkRhdGUiLCJtb2RlIiwib2tMYWJlbCIsInNob3VsZERpc2FibGVEYXRlIiwic3R5bGUiLCJhbmltYXRpb24iLCJvdGhlciIsInN0eWxlcyIsImRpYWxvZ0NvbnRlbnQiLCJ3aWR0aCIsImRpYWxvZ0JvZHlDb250ZW50IiwicGFkZGluZyIsIm1pbkhlaWdodCIsIm1pbldpZHRoIiwiQ29udGFpbmVyIiwicm9vdCIsInByb3BUeXBlcyIsImZ1bmMiLCJib29sIiwibm9kZSIsIm9uZU9mIiwib2JqZWN0IiwibnVtYmVyIiwic3RyaW5nIiwiZGVmYXVsdFByb3BzIiwiY29udGV4dFR5cGVzIiwibXVpVGhlbWUiLCJpc1JlcXVpcmVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztB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dUMsSUFIRDtBQUlqQjFCLGVBQWEsaUJBQVUyQixJQUpOO0FBS2pCMUIsYUFBVyxpQkFBVTJCLEtBQVYsQ0FBZ0IsQ0FBQyxRQUFELEVBQVcsUUFBWCxDQUFoQixDQUxNO0FBTWpCMUIsa0JBQWdCLGlCQUFVMkIsTUFOVDtBQU9qQjFCLHdCQUFzQixpQkFBVXVCLElBUGY7QUFRakJyQixrQkFBZ0IsaUJBQVV5QixNQVJUO0FBU2pCMUIsZUFBYSxpQkFBVXlCLE1BVE47QUFVakJ2QixVQUFRLGlCQUFVeUIsTUFWRDtBQVdqQnhCLFdBQVMsaUJBQVVzQixNQVhGO0FBWWpCckIsV0FBUyxpQkFBVXFCLE1BWkY7QUFhakJwQixRQUFNLGlCQUFVbUIsS0FBVixDQUFnQixDQUFDLFVBQUQsRUFBYSxXQUFiLENBQWhCLENBYlc7QUFjakJsQixXQUFTLGlCQUFVaUIsSUFkRjtBQWVqQm5DLFlBQVUsaUJBQVVpQyxJQWZIO0FBZ0JqQnhDLGFBQVcsaUJBQVV3QyxJQWhCSjtBQWlCakIzQyxVQUFRLGlCQUFVMkMsSUFqQkQ7QUFrQmpCOUMsUUFBTSxpQkFBVStDLElBbEJDO0FBbUJqQmYscUJBQW1CLGlCQUFVYyxJQW5CWjtBQW9CakJiLFNBQU8saUJBQVVpQjtBQXBCQSxDO0FBRGZwRCxnQixDQXdCR3VELFksR0FBZTtBQUNwQmpDLDJDQURvQjtBQUVwQkMsZUFBYSxRQUZPO0FBR3BCQyxhQUFXLFFBSFM7QUFJcEJLLFVBQVEsT0FKWTtBQUtwQkksV0FBUztBQUxXLEM7QUF4QmxCakMsZ0IsQ0FnQ0d3RCxZLEdBQWU7QUFDcEJDLFlBQVUsaUJBQVVMLE1BQVYsQ0FBaUJNO0FBRFAsQztlQStJVDFELGdCOzs7Ozs7Ozs7Z0NBL0tUQSxnQiIsImZpbGUiOiJEYXRlUGlja2VyRGlhbG9nLmpzIiwic291cmNlUm9vdCI6Ii9Vc2Vycy90bWFjX3pjL0NvZGUva3ItYWRtaW4iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHtDb21wb25lbnQsIFByb3BUeXBlc30gZnJvbSAncmVhY3QnO1xuaW1wb3J0IEV2ZW50TGlzdGVuZXIgZnJvbSAncmVhY3QtZXZlbnQtbGlzdGVuZXInO1xuaW1wb3J0IGtleWNvZGUgZnJvbSAna2V5Y29kZSc7XG5pbXBvcnQgQ2FsZW5kYXIgZnJvbSAnLi9DYWxlbmRhcic7XG5pbXBvcnQgRGlhbG9nIGZyb20gJy4uL0RpYWxvZyc7XG5pbXBvcnQgUG9wb3ZlciBmcm9tICcuLi9Qb3BvdmVyL1BvcG92ZXInO1xuaW1wb3J0IFBvcG92ZXJBbmltYXRpb25WZXJ0aWNhbCBmcm9tICcuLi9Qb3BvdmVyL1BvcG92ZXJBbmltYXRpb25WZXJ0aWNhbCc7XG5pbXBvcnQge2RhdGVUaW1lRm9ybWF0fSBmcm9tICcuL2RhdGVVdGlscyc7XG5cbmNsYXNzIERhdGVQaWNrZXJEaWFsb2cgZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIERhdGVUaW1lRm9ybWF0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBhbmltYXRpb246IFByb3BUeXBlcy5mdW5jLFxuICAgIGF1dG9PazogUHJvcFR5cGVzLmJvb2wsXG4gICAgY2FuY2VsTGFiZWw6IFByb3BUeXBlcy5ub2RlLFxuICAgIGNvbnRhaW5lcjogUHJvcFR5cGVzLm9uZU9mKFsnZGlhbG9nJywgJ2lubGluZSddKSxcbiAgICBjb250YWluZXJTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBkaXNhYmxlWWVhclNlbGVjdGlvbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgZmlyc3REYXlPZldlZWs6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgaW5pdGlhbERhdGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgbG9jYWxlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG1heERhdGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgbWluRGF0ZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBtb2RlOiBQcm9wVHlwZXMub25lT2YoWydwb3J0cmFpdCcsICdsYW5kc2NhcGUnXSksXG4gICAgb2tMYWJlbDogUHJvcFR5cGVzLm5vZGUsXG4gICAgb25BY2NlcHQ6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRGlzbWlzczogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25TaG93OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvcGVuOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBzaG91bGREaXNhYmxlRGF0ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBEYXRlVGltZUZvcm1hdDogZGF0ZVRpbWVGb3JtYXQsXG4gICAgY2FuY2VsTGFiZWw6ICdDYW5jZWwnLFxuICAgIGNvbnRhaW5lcjogJ2RpYWxvZycsXG4gICAgbG9jYWxlOiAnZW4tVVMnLFxuICAgIG9rTGFiZWw6ICdPSycsXG4gIH07XG5cbiAgc3RhdGljIGNvbnRleHRUeXBlcyA9IHtcbiAgICBtdWlUaGVtZTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICB9O1xuXG4gIHN0YXRlID0ge1xuICAgIG9wZW46IGZhbHNlLFxuICB9O1xuXG4gIHNob3cgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMub25TaG93ICYmICF0aGlzLnN0YXRlLm9wZW4pIHtcbiAgICAgIHRoaXMucHJvcHMub25TaG93KCk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBvcGVuOiB0cnVlLFxuICAgIH0pO1xuICB9O1xuXG4gIGRpc21pc3MgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMub25EaXNtaXNzICYmIHRoaXMuc3RhdGUub3Blbikge1xuICAgICAgdGhpcy5wcm9wcy5vbkRpc21pc3MoKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIG9wZW46IGZhbHNlLFxuICAgIH0pO1xuICB9O1xuXG4gIGhhbmRsZVRvdWNoVGFwRGF5ID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLnByb3BzLmF1dG9Paykge1xuICAgICAgc2V0VGltZW91dCh0aGlzLmhhbmRsZVRvdWNoVGFwT2ssIDApO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVUb3VjaFRhcENhbmNlbCA9ICgpID0+IHtcbiAgICB0aGlzLmRpc21pc3MoKTtcbiAgfTtcblxuICBoYW5kbGVSZXF1ZXN0Q2xvc2UgPSAoKSA9PiB7XG4gICAgdGhpcy5kaXNtaXNzKCk7XG4gIH07XG5cbiAgaGFuZGxlVG91Y2hUYXBPayA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5wcm9wcy5vbkFjY2VwdCAmJiAhdGhpcy5yZWZzLmNhbGVuZGFyLmlzU2VsZWN0ZWREYXRlRGlzYWJsZWQoKSkge1xuXG4gICAgICB0aGlzLnByb3BzLm9uQWNjZXB0KHRoaXMucmVmcy5jYWxlbmRhci5nZXRTZWxlY3RlZERhdGUoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBvcGVuOiBmYWxzZSxcbiAgICB9KTtcbiAgfTtcblxuICBoYW5kbGVXaW5kb3dLZXlVcCA9IChldmVudCkgPT4ge1xuICAgIHN3aXRjaCAoa2V5Y29kZShldmVudCkpIHtcbiAgICAgIGNhc2UgJ2VudGVyJzpcbiAgICAgICAgdGhpcy5oYW5kbGVUb3VjaFRhcE9rKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgRGF0ZVRpbWVGb3JtYXQsXG4gICAgICBhdXRvT2ssXG4gICAgICBjYW5jZWxMYWJlbCxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGNvbnRhaW5lclN0eWxlLFxuICAgICAgZGlzYWJsZVllYXJTZWxlY3Rpb24sXG4gICAgICBpbml0aWFsRGF0ZSxcbiAgICAgIGZpcnN0RGF5T2ZXZWVrLFxuICAgICAgbG9jYWxlLFxuICAgICAgbWF4RGF0ZSxcbiAgICAgIG1pbkRhdGUsXG4gICAgICBtb2RlLFxuICAgICAgb2tMYWJlbCxcbiAgICAgIG9uQWNjZXB0LCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBvbkRpc21pc3MsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIG9uU2hvdywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgc2hvdWxkRGlzYWJsZURhdGUsXG4gICAgICBzdHlsZSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgYW5pbWF0aW9uLFxuICAgICAgLi4ub3RoZXJcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IHtvcGVufSA9IHRoaXMuc3RhdGU7XG5cbiAgICBjb25zdCBzdHlsZXMgPSB7XG4gICAgICBkaWFsb2dDb250ZW50OiB7XG4gICAgICAgIHdpZHRoOiBtb2RlID09PSAnbGFuZHNjYXBlJyA/IDQ3OSA6IDMxMCxcbiAgICAgIH0sXG4gICAgICBkaWFsb2dCb2R5Q29udGVudDoge1xuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAvL21pbkhlaWdodDogbW9kZSA9PT0gJ2xhbmRzY2FwZScgPyAzMzAgOiA0MzQsXG4gICAgICAgIG1pbkhlaWdodDogbW9kZSA9PT0gJ2xhbmRzY2FwZScgPyAzMzAgOiAzMTAsXG4gICAgICAgIG1pbldpZHRoOiBtb2RlID09PSAnbGFuZHNjYXBlJyA/IDQ3OSA6IDMxMCxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGNvbnN0IENvbnRhaW5lciA9IChjb250YWluZXIgPT09ICdpbmxpbmUnID8gUG9wb3ZlciA6IERpYWxvZyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiB7Li4ub3RoZXJ9IHJlZj1cInJvb3RcIj5cbiAgICAgICAgPENvbnRhaW5lclxuICAgICAgICAgIGFuY2hvckVsPXt0aGlzLnJlZnMucm9vdH0gLy8gRm9yIFBvcG92ZXJcbiAgICAgICAgICBhbmltYXRpb249e2FuaW1hdGlvbiB8fCBQb3BvdmVyQW5pbWF0aW9uVmVydGljYWx9IC8vIEZvciBQb3BvdmVyXG4gICAgICAgICAgYm9keVN0eWxlPXtzdHlsZXMuZGlhbG9nQm9keUNvbnRlbnR9XG4gICAgICAgICAgY29udGVudFN0eWxlPXtzdHlsZXMuZGlhbG9nQ29udGVudH1cbiAgICAgICAgICByZWY9XCJkaWFsb2dcIlxuICAgICAgICAgIHJlcG9zaXRpb25PblVwZGF0ZT17dHJ1ZX1cbiAgICAgICAgICBvcGVuPXtvcGVufVxuICAgICAgICAgIG9uUmVxdWVzdENsb3NlPXt0aGlzLmhhbmRsZVJlcXVlc3RDbG9zZX1cbiAgICAgICAgICBzdHlsZT17T2JqZWN0LmFzc2lnbihzdHlsZXMuZGlhbG9nQm9keUNvbnRlbnQsIGNvbnRhaW5lclN0eWxlKX1cbiAgICAgICAgPlxuICAgICAgICAgIDxFdmVudExpc3RlbmVyXG4gICAgICAgICAgICB0YXJnZXQ9XCJ3aW5kb3dcIlxuICAgICAgICAgICAgb25LZXlVcD17dGhpcy5oYW5kbGVXaW5kb3dLZXlVcH1cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxDYWxlbmRhclxuICAgICAgICAgICAgYXV0b09rPXthdXRvT2t9XG4gICAgICAgICAgICBEYXRlVGltZUZvcm1hdD17RGF0ZVRpbWVGb3JtYXR9XG4gICAgICAgICAgICBjYW5jZWxMYWJlbD17Y2FuY2VsTGFiZWx9XG4gICAgICAgICAgICBkaXNhYmxlWWVhclNlbGVjdGlvbj17ZGlzYWJsZVllYXJTZWxlY3Rpb259XG4gICAgICAgICAgICBmaXJzdERheU9mV2Vlaz17Zmlyc3REYXlPZldlZWt9XG4gICAgICAgICAgICBpbml0aWFsRGF0ZT17aW5pdGlhbERhdGV9XG4gICAgICAgICAgICBsb2NhbGU9e2xvY2FsZX1cbiAgICAgICAgICAgIG9uVG91Y2hUYXBEYXk9e3RoaXMuaGFuZGxlVG91Y2hUYXBEYXl9XG4gICAgICAgICAgICBtYXhEYXRlPXttYXhEYXRlfVxuICAgICAgICAgICAgbWluRGF0ZT17bWluRGF0ZX1cbiAgICAgICAgICAgIG1vZGU9e21vZGV9XG4gICAgICAgICAgICBvcGVuPXtvcGVufVxuICAgICAgICAgICAgcmVmPVwiY2FsZW5kYXJcIlxuICAgICAgICAgICAgb25Ub3VjaFRhcENhbmNlbD17dGhpcy5oYW5kbGVUb3VjaFRhcENhbmNlbH1cbiAgICAgICAgICAgIG9uVG91Y2hUYXBPaz17dGhpcy5oYW5kbGVUb3VjaFRhcE9rfVxuICAgICAgICAgICAgb2tMYWJlbD17b2tMYWJlbH1cbiAgICAgICAgICAgIHNob3VsZERpc2FibGVEYXRlPXtzaG91bGREaXNhYmxlRGF0ZX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L0NvbnRhaW5lcj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGF0ZVBpY2tlckRpYWxvZztcbiJdfQ==