{"version":3,"sources":["src/Components/DatePicker/internal/TouchRipple.js"],"names":["shift","newArray","TouchRipple","props","context","handleMouseDown","event","button","start","handleMouseUp","end","handleMouseLeave","handleTouchStart","stopPropagation","abortOnScroll","touches","startListeningForScrollAbort","startTime","Date","now","handleTouchEnd","handleTouchMove","timeSinceStart","Math","abs","stopListeningForScrollAbort","deltaY","clientY","firstTouchY","deltaX","clientX","firstTouchX","currentRipples","state","ripples","ripple","abortedRipple","cloneElement","aborted","setState","ignoreNextMouseDown","hasRipples","nextKey","isRippleTouchGenerated","theme","muiTheme","centerRipple","getRippleStyle","color","opacity","document","body","addEventListener","removeEventListener","el","findDOMNode","elHeight","offsetHeight","elWidth","offsetWidth","offset","isTouchEvent","length","pageX","pageY","pointerX","left","pointerY","top","topLeftDiag","calcDiag","topRightDiag","botRightDiag","botLeftDiag","rippleRadius","max","rippleSize","directionInvariant","height","width","a","b","sqrt","children","style","prepareStyles","rippleGroup","mergedStyles","position","overflow","propTypes","bool","node","string","number","object","defaultProps","contextTypes","isRequired"],"mappings":"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","file":"TouchRipple.js","sourceRoot":"/Users/tmac_zc/Code/kr-admin","sourcesContent":["import React, {Component, PropTypes} from 'react';\nimport ReactDOM from 'react-dom';\nimport ReactTransitionGroup from 'react-addons-transition-group';\nimport Dom from '../utils/dom';\nimport CircleRipple from './CircleRipple';\n\n// Remove the first element of the array\nconst shift = ([, ...newArray]) => newArray;\n\nclass TouchRipple extends Component {\n  static propTypes = {\n    abortOnScroll: PropTypes.bool,\n    centerRipple: PropTypes.bool,\n    children: PropTypes.node,\n    color: PropTypes.string,\n    opacity: PropTypes.number,\n    style: PropTypes.object,\n  };\n\n  static defaultProps = {\n    abortOnScroll: true,\n  };\n\n  static contextTypes = {\n    muiTheme: PropTypes.object.isRequired,\n  };\n\n  constructor(props, context) {\n    super(props, context);\n    // Touch start produces a mouse down event for compat reasons. To avoid\n    // showing ripples twice we skip showing a ripple for the first mouse down\n    // after a touch start. Note we don't store ignoreNextMouseDown in this.state\n    // to avoid re-rendering when we change it.\n    this.ignoreNextMouseDown = false;\n\n    this.state = {\n      // This prop allows us to only render the ReactTransitionGroup\n      // on the first click of the component, making the inital render faster.\n      hasRipples: false,\n      nextKey: 0,\n      ripples: [],\n    };\n  }\n\n  start(event, isRippleTouchGenerated) {\n    const theme = this.context.muiTheme.ripple;\n\n    if (this.ignoreNextMouseDown && !isRippleTouchGenerated) {\n      this.ignoreNextMouseDown = false;\n      return;\n    }\n\n    let ripples = this.state.ripples;\n\n    // Add a ripple to the ripples array\n    ripples = [...ripples, (\n      <CircleRipple\n        key={this.state.nextKey}\n        style={!this.props.centerRipple ? this.getRippleStyle(event) : {}}\n        color={this.props.color || theme.color}\n        opacity={this.props.opacity}\n        touchGenerated={isRippleTouchGenerated}\n      />\n    )];\n\n    this.ignoreNextMouseDown = isRippleTouchGenerated;\n    this.setState({\n      hasRipples: true,\n      nextKey: this.state.nextKey + 1,\n      ripples: ripples,\n    });\n  }\n\n  end() {\n    const currentRipples = this.state.ripples;\n    this.setState({\n      ripples: shift(currentRipples),\n    });\n    if (this.props.abortOnScroll) {\n      this.stopListeningForScrollAbort();\n    }\n  }\n\n  handleMouseDown = (event) => {\n    // only listen to left clicks\n    if (event.button === 0) {\n      this.start(event, false);\n    }\n  };\n\n  handleMouseUp = () => {\n    this.end();\n  };\n\n  handleMouseLeave = () => {\n    this.end();\n  };\n\n  handleTouchStart = (event) => {\n    event.stopPropagation();\n    // If the user is swiping (not just tapping), save the position so we can\n    // abort ripples if the user appears to be scrolling.\n    if (this.props.abortOnScroll && event.touches) {\n      this.startListeningForScrollAbort(event);\n      this.startTime = Date.now();\n    }\n    this.start(event, true);\n  };\n\n  handleTouchEnd = () => {\n    this.end();\n  };\n\n  // Check if the user seems to be scrolling and abort the animation if so\n  handleTouchMove = (event) => {\n    // Stop trying to abort if we're already 300ms into the animation\n    const timeSinceStart = Math.abs(Date.now() - this.startTime);\n    if (timeSinceStart > 300) {\n      this.stopListeningForScrollAbort();\n      return;\n    }\n\n    // If the user is scrolling...\n    const deltaY = Math.abs(event.touches[0].clientY - this.firstTouchY);\n    const deltaX = Math.abs(event.touches[0].clientX - this.firstTouchX);\n    // Call it a scroll after an arbitrary 6px (feels reasonable in testing)\n    if (deltaY > 6 || deltaX > 6) {\n      let currentRipples = this.state.ripples;\n      const ripple = currentRipples[0];\n      // This clone will replace the ripple in ReactTransitionGroup with a\n      // version that will disappear immediately when removed from the DOM\n      const abortedRipple = React.cloneElement(ripple, {aborted: true});\n      // Remove the old ripple and replace it with the new updated one\n      currentRipples = shift(currentRipples);\n      currentRipples = [...currentRipples, abortedRipple];\n      this.setState({ripples: currentRipples}, () => {\n        // Call end after we've set the ripple to abort otherwise the setState\n        // in end() merges with this and the ripple abort fails\n        this.end();\n      });\n    }\n  };\n\n  startListeningForScrollAbort(event) {\n    this.firstTouchY = event.touches[0].clientY;\n    this.firstTouchX = event.touches[0].clientX;\n    // Note that when scolling Chrome throttles this event to every 200ms\n    // Also note we don't listen for scroll events directly as there's no general\n    // way to cover cases like scrolling within containers on the page\n    document.body.addEventListener('touchmove', this.handleTouchMove);\n  }\n\n  stopListeningForScrollAbort() {\n    document.body.removeEventListener('touchmove', this.handleTouchMove);\n  }\n\n  getRippleStyle(event) {\n    const el = ReactDOM.findDOMNode(this);\n    const elHeight = el.offsetHeight;\n    const elWidth = el.offsetWidth;\n    const offset = Dom.offset(el);\n    const isTouchEvent = event.touches && event.touches.length;\n    const pageX = isTouchEvent ? event.touches[0].pageX : event.pageX;\n    const pageY = isTouchEvent ? event.touches[0].pageY : event.pageY;\n    const pointerX = pageX - offset.left;\n    const pointerY = pageY - offset.top;\n    const topLeftDiag = this.calcDiag(pointerX, pointerY);\n    const topRightDiag = this.calcDiag(elWidth - pointerX, pointerY);\n    const botRightDiag = this.calcDiag(elWidth - pointerX, elHeight - pointerY);\n    const botLeftDiag = this.calcDiag(pointerX, elHeight - pointerY);\n    const rippleRadius = Math.max(\n      topLeftDiag, topRightDiag, botRightDiag, botLeftDiag\n    );\n    const rippleSize = rippleRadius * 2;\n    const left = pointerX - rippleRadius;\n    const top = pointerY - rippleRadius;\n\n    return {\n      directionInvariant: true,\n      height: rippleSize,\n      width: rippleSize,\n      top: top,\n      left: left,\n    };\n  }\n\n  calcDiag(a, b) {\n    return Math.sqrt((a * a) + (b * b));\n  }\n\n  render() {\n    const {children, style} = this.props;\n    const {hasRipples, ripples} = this.state;\n    const {prepareStyles} = this.context.muiTheme;\n\n    let rippleGroup;\n\n    if (hasRipples) {\n      const mergedStyles = Object.assign({\n        height: '100%',\n        width: '100%',\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        overflow: 'hidden',\n      }, style);\n\n      rippleGroup = (\n        <ReactTransitionGroup style={prepareStyles(mergedStyles)}>\n          {ripples}\n        </ReactTransitionGroup>\n      );\n    }\n\n    return (\n      <div\n        onMouseUp={this.handleMouseUp}\n        onMouseDown={this.handleMouseDown}\n        onMouseLeave={this.handleMouseLeave}\n        onTouchStart={this.handleTouchStart}\n        onTouchEnd={this.handleTouchEnd}\n      >\n        {rippleGroup}\n        {children}\n      </div>\n    );\n  }\n}\n\nexport default TouchRipple;\n"]}