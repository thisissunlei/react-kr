'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _transitions = require('../styles/transitions');

var _transitions2 = _interopRequireDefault(_transitions);

var _SlideIn = require('../internal/SlideIn');

var _SlideIn2 = _interopRequireDefault(_SlideIn);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function getStyles(props, context, state) {
  var datePicker = context.muiTheme.datePicker;
  var selectedYear = state.selectedYear;

  var isLandscape = props.mode === 'landscape';

  var styles = {
    root: {
      width: isLandscape ? 165 : '100%',
      height: isLandscape ? 330 : 'auto',
      float: isLandscape ? 'left' : 'none',
      fontWeight: 700,
      display: 'inline-block',
      backgroundColor: datePicker.selectColor,
      borderTopLeftRadius: 2,
      borderTopRightRadius: isLandscape ? 0 : 2,
      borderBottomLeftRadius: isLandscape ? 2 : 0,
      color: datePicker.textColor,
      padding: 20,
      boxSizing: 'border-box'
    },
    monthDay: {
      display: 'block',
      fontSize: 36,
      lineHeight: '36px',
      height: props.mode === 'landscape' ? '100%' : 38,
      opacity: selectedYear ? 0.7 : 1,
      transition: _transitions2.default.easeOut(),
      width: '100%',
      fontWeight: '500'
    },
    monthDayTitle: {
      cursor: !selectedYear ? 'default' : 'pointer',
      width: '100%',
      display: 'block'
    },
    year: {
      margin: 0,
      fontSize: 16,
      fontWeight: '500',
      lineHeight: '16px',
      height: 16,
      opacity: selectedYear ? 1 : 0.7,
      transition: _transitions2.default.easeOut(),
      marginBottom: 10
    },
    yearTitle: {
      cursor: props.disableYearSelection ? 'not-allowed' : !selectedYear ? 'pointer' : 'default'
    }
  };

  return styles;
}

var DateDisplay = function (_Component) {
  _inherits(DateDisplay, _Component);

  function DateDisplay() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, DateDisplay);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = DateDisplay.__proto__ || Object.getPrototypeOf(DateDisplay)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      selectedYear: false,
      transitionDirection: 'up'
    }, _this.handleTouchTapMonthDay = function () {
      if (_this.props.onTouchTapMonthDay && _this.state.selectedYear) {
        _this.props.onTouchTapMonthDay();
      }

      _this.setState({ selectedYear: false });
    }, _this.handleTouchTapYear = function () {
      if (_this.props.onTouchTapYear && !_this.props.disableYearSelection && !_this.state.selectedYear) {
        _this.props.onTouchTapYear();
      }

      if (!_this.props.disableYearSelection) {
        _this.setState({ selectedYear: true });
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(DateDisplay, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      if (!this.props.monthDaySelected) {
        this.setState({ selectedYear: true });
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.selectedDate !== this.props.selectedDate) {
        var direction = nextProps.selectedDate > this.props.selectedDate ? 'up' : 'down';
        this.setState({
          transitionDirection: direction
        });
      }

      if (nextProps.monthDaySelected !== undefined) {
        this.setState({
          selectedYear: !nextProps.monthDaySelected
        });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          DateTimeFormat = _props.DateTimeFormat,
          disableYearSelection = _props.disableYearSelection,
          locale = _props.locale,
          mode = _props.mode,
          monthDaySelected = _props.monthDaySelected,
          onTouchTapMonthDay = _props.onTouchTapMonthDay,
          onTouchTapYear = _props.onTouchTapYear,
          selectedDate = _props.selectedDate,
          style = _props.style,
          other = _objectWithoutProperties(_props, ['DateTimeFormat', 'disableYearSelection', 'locale', 'mode', 'monthDaySelected', 'onTouchTapMonthDay', 'onTouchTapYear', 'selectedDate', 'style']);

      var prepareStyles = this.context.muiTheme.prepareStyles;

      var styles = getStyles(this.props, this.context, this.state);

      var year = new DateTimeFormat(locale, {
        year: 'numeric'
      }).format(selectedDate);

      var dateTime = new DateTimeFormat(locale, {
        month: 'short',
        weekday: 'short',
        day: '2-digit'
      }).format(selectedDate);

      return _react2.default.createElement(
        'div',
        _extends({}, other, { style: prepareStyles(styles.root, style) }),
        _react2.default.createElement(
          _SlideIn2.default,
          { style: styles.year, direction: this.state.transitionDirection },
          _react2.default.createElement(
            'div',
            { key: year, style: styles.yearTitle, onTouchTap: this.handleTouchTapYear },
            year
          )
        ),
        _react2.default.createElement(
          _SlideIn2.default,
          { style: styles.monthDay, direction: this.state.transitionDirection },
          _react2.default.createElement(
            'div',
            {
              key: dateTime,
              onTouchTap: this.handleTouchTapMonthDay,
              style: styles.monthDayTitle
            },
            dateTime
          )
        )
      );
    }
  }]);

  return DateDisplay;
}(_react.Component);

DateDisplay.propTypes = {
  DateTimeFormat: _react.PropTypes.func.isRequired,
  disableYearSelection: _react.PropTypes.bool,
  locale: _react.PropTypes.string.isRequired,
  mode: _react.PropTypes.oneOf(['portrait', 'landscape']),
  monthDaySelected: _react.PropTypes.bool,
  onTouchTapMonthDay: _react.PropTypes.func,
  onTouchTapYear: _react.PropTypes.func,
  selectedDate: _react.PropTypes.object.isRequired,
  style: _react.PropTypes.object
};
DateDisplay.defaultProps = {
  disableYearSelection: false,
  monthDaySelected: true
};
DateDisplay.contextTypes = {
  muiTheme: _react.PropTypes.object.isRequired
};
var _default = DateDisplay;
exports.default = _default;
;

var _temp2 = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(getStyles, 'getStyles', '/Users/liuyihao/Code/kr-admin/src/Components/DatePicker/DatePicker/DateDisplay.js');

  __REACT_HOT_LOADER__.register(DateDisplay, 'DateDisplay', '/Users/liuyihao/Code/kr-admin/src/Components/DatePicker/DatePicker/DateDisplay.js');

  __REACT_HOT_LOADER__.register(_default, 'default', '/Users/liuyihao/Code/kr-admin/src/Components/DatePicker/DatePicker/DateDisplay.js');
}();

;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9Db21wb25lbnRzL0RhdGVQaWNrZXIvRGF0ZVBpY2tlci9EYXRlRGlzcGxheS5qcyJdLCJuYW1lcyI6WyJnZXRTdHlsZXMiLCJwcm9wcyIsImNvbnRleHQiLCJzdGF0ZSIsImRhdGVQaWNrZXIiLCJtdWlUaGVtZSIsInNlbGVjdGVkWWVhciIsImlzTGFuZHNjYXBlIiwibW9kZSIsInN0eWxlcyIsInJvb3QiLCJ3aWR0aCIsImhlaWdodCIsImZsb2F0IiwiZm9udFdlaWdodCIsImRpc3BsYXkiLCJiYWNrZ3JvdW5kQ29sb3IiLCJzZWxlY3RDb2xvciIsImJvcmRlclRvcExlZnRSYWRpdXMiLCJib3JkZXJUb3BSaWdodFJhZGl1cyIsImJvcmRlckJvdHRvbUxlZnRSYWRpdXMiLCJjb2xvciIsInRleHRDb2xvciIsInBhZGRpbmciLCJib3hTaXppbmciLCJtb250aERheSIsImZvbnRTaXplIiwibGluZUhlaWdodCIsIm9wYWNpdHkiLCJ0cmFuc2l0aW9uIiwiZWFzZU91dCIsIm1vbnRoRGF5VGl0bGUiLCJjdXJzb3IiLCJ5ZWFyIiwibWFyZ2luIiwibWFyZ2luQm90dG9tIiwieWVhclRpdGxlIiwiZGlzYWJsZVllYXJTZWxlY3Rpb24iLCJEYXRlRGlzcGxheSIsInRyYW5zaXRpb25EaXJlY3Rpb24iLCJoYW5kbGVUb3VjaFRhcE1vbnRoRGF5Iiwib25Ub3VjaFRhcE1vbnRoRGF5Iiwic2V0U3RhdGUiLCJoYW5kbGVUb3VjaFRhcFllYXIiLCJvblRvdWNoVGFwWWVhciIsIm1vbnRoRGF5U2VsZWN0ZWQiLCJuZXh0UHJvcHMiLCJzZWxlY3RlZERhdGUiLCJkaXJlY3Rpb24iLCJ1bmRlZmluZWQiLCJEYXRlVGltZUZvcm1hdCIsImxvY2FsZSIsInN0eWxlIiwib3RoZXIiLCJwcmVwYXJlU3R5bGVzIiwiZm9ybWF0IiwiZGF0ZVRpbWUiLCJtb250aCIsIndlZWtkYXkiLCJkYXkiLCJwcm9wVHlwZXMiLCJmdW5jIiwiaXNSZXF1aXJlZCIsImJvb2wiLCJzdHJp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QnRCLHNCQUFvQixpQkFBVW9CLElBTmI7QUFPakJqQixrQkFBZ0IsaUJBQVVpQixJQVBUO0FBUWpCZCxnQkFBYyxpQkFBVW1CLE1BQVYsQ0FBaUJKLFVBUmQ7QUFTakJWLFNBQU8saUJBQVVjO0FBVEEsQztBQURmNUIsVyxDQWFHNkIsWSxHQUFlO0FBQ3BCOUIsd0JBQXNCLEtBREY7QUFFcEJRLG9CQUFrQjtBQUZFLEM7QUFibEJQLFcsQ0FrQkc4QixZLEdBQWU7QUFDcEIvRCxZQUFVLGlCQUFVNkQsTUFBVixDQUFpQko7QUFEUCxDO2VBaUdUeEIsVzs7Ozs7Ozs7O2dDQXhLTnRDLFM7O2dDQXFESHNDLFciLCJmaWxlIjoiRGF0ZURpc3BsYXkuanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL2xpdXlpaGFvL0NvZGUva3ItYWRtaW4iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHtDb21wb25lbnQsIFByb3BUeXBlc30gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHRyYW5zaXRpb25zIGZyb20gJy4uL3N0eWxlcy90cmFuc2l0aW9ucyc7XG5pbXBvcnQgU2xpZGVJblRyYW5zaXRpb25Hcm91cCBmcm9tICcuLi9pbnRlcm5hbC9TbGlkZUluJztcblxuZnVuY3Rpb24gZ2V0U3R5bGVzKHByb3BzLCBjb250ZXh0LCBzdGF0ZSkge1xuICBjb25zdCB7ZGF0ZVBpY2tlcn0gPSBjb250ZXh0Lm11aVRoZW1lO1xuICBjb25zdCB7c2VsZWN0ZWRZZWFyfSA9IHN0YXRlO1xuICBjb25zdCBpc0xhbmRzY2FwZSA9IHByb3BzLm1vZGUgPT09ICdsYW5kc2NhcGUnO1xuXG4gIGNvbnN0IHN0eWxlcyA9IHtcbiAgICByb290OiB7XG4gICAgICB3aWR0aDogaXNMYW5kc2NhcGUgPyAxNjUgOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6IGlzTGFuZHNjYXBlID8gMzMwIDogJ2F1dG8nLFxuICAgICAgZmxvYXQ6IGlzTGFuZHNjYXBlID8gJ2xlZnQnIDogJ25vbmUnLFxuICAgICAgZm9udFdlaWdodDogNzAwLFxuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGRhdGVQaWNrZXIuc2VsZWN0Q29sb3IsXG4gICAgICBib3JkZXJUb3BMZWZ0UmFkaXVzOiAyLFxuICAgICAgYm9yZGVyVG9wUmlnaHRSYWRpdXM6IGlzTGFuZHNjYXBlID8gMCA6IDIsXG4gICAgICBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiBpc0xhbmRzY2FwZSA/IDIgOiAwLFxuICAgICAgY29sb3I6IGRhdGVQaWNrZXIudGV4dENvbG9yLFxuICAgICAgcGFkZGluZzogMjAsXG4gICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICB9LFxuICAgIG1vbnRoRGF5OiB7XG4gICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgZm9udFNpemU6IDM2LFxuICAgICAgbGluZUhlaWdodDogJzM2cHgnLFxuICAgICAgaGVpZ2h0OiBwcm9wcy5tb2RlID09PSAnbGFuZHNjYXBlJyA/ICcxMDAlJyA6IDM4LFxuICAgICAgb3BhY2l0eTogc2VsZWN0ZWRZZWFyID8gMC43IDogMSxcbiAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb25zLmVhc2VPdXQoKSxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBmb250V2VpZ2h0OiAnNTAwJyxcbiAgICB9LFxuICAgIG1vbnRoRGF5VGl0bGU6IHtcbiAgICAgIGN1cnNvcjogIXNlbGVjdGVkWWVhciA/ICdkZWZhdWx0JyA6ICdwb2ludGVyJyxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgIH0sXG4gICAgeWVhcjoge1xuICAgICAgbWFyZ2luOiAwLFxuICAgICAgZm9udFNpemU6IDE2LFxuICAgICAgZm9udFdlaWdodDogJzUwMCcsXG4gICAgICBsaW5lSGVpZ2h0OiAnMTZweCcsXG4gICAgICBoZWlnaHQ6IDE2LFxuICAgICAgb3BhY2l0eTogc2VsZWN0ZWRZZWFyID8gMSA6IDAuNyxcbiAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb25zLmVhc2VPdXQoKSxcbiAgICAgIG1hcmdpbkJvdHRvbTogMTAsXG4gICAgfSxcbiAgICB5ZWFyVGl0bGU6IHtcbiAgICAgIGN1cnNvcjogcHJvcHMuZGlzYWJsZVllYXJTZWxlY3Rpb24gPyAnbm90LWFsbG93ZWQnIDogKCFzZWxlY3RlZFllYXIgPyAncG9pbnRlcicgOiAnZGVmYXVsdCcpLFxuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIHN0eWxlcztcbn1cblxuY2xhc3MgRGF0ZURpc3BsYXkgZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIERhdGVUaW1lRm9ybWF0OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIGRpc2FibGVZZWFyU2VsZWN0aW9uOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBsb2NhbGU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBtb2RlOiBQcm9wVHlwZXMub25lT2YoWydwb3J0cmFpdCcsICdsYW5kc2NhcGUnXSksXG4gICAgbW9udGhEYXlTZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgb25Ub3VjaFRhcE1vbnRoRGF5OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblRvdWNoVGFwWWVhcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgc2VsZWN0ZWREYXRlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBkaXNhYmxlWWVhclNlbGVjdGlvbjogZmFsc2UsXG4gICAgbW9udGhEYXlTZWxlY3RlZDogdHJ1ZSxcbiAgfTtcblxuICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgIG11aVRoZW1lOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIH07XG5cbiAgc3RhdGUgPSB7XG4gICAgc2VsZWN0ZWRZZWFyOiBmYWxzZSxcbiAgICB0cmFuc2l0aW9uRGlyZWN0aW9uOiAndXAnLFxuICB9O1xuXG4gIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBpZiAoIXRoaXMucHJvcHMubW9udGhEYXlTZWxlY3RlZCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7c2VsZWN0ZWRZZWFyOiB0cnVlfSk7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLnNlbGVjdGVkRGF0ZSAhPT0gdGhpcy5wcm9wcy5zZWxlY3RlZERhdGUpIHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5leHRQcm9wcy5zZWxlY3RlZERhdGUgPiB0aGlzLnByb3BzLnNlbGVjdGVkRGF0ZSA/ICd1cCcgOiAnZG93bic7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdHJhbnNpdGlvbkRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG5leHRQcm9wcy5tb250aERheVNlbGVjdGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBzZWxlY3RlZFllYXI6ICFuZXh0UHJvcHMubW9udGhEYXlTZWxlY3RlZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVRvdWNoVGFwTW9udGhEYXkgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMub25Ub3VjaFRhcE1vbnRoRGF5ICYmIHRoaXMuc3RhdGUuc2VsZWN0ZWRZZWFyKSB7XG4gICAgICB0aGlzLnByb3BzLm9uVG91Y2hUYXBNb250aERheSgpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoe3NlbGVjdGVkWWVhcjogZmFsc2V9KTtcbiAgfTtcblxuICBoYW5kbGVUb3VjaFRhcFllYXIgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMub25Ub3VjaFRhcFllYXIgJiYgIXRoaXMucHJvcHMuZGlzYWJsZVllYXJTZWxlY3Rpb24gJiYgIXRoaXMuc3RhdGUuc2VsZWN0ZWRZZWFyKSB7XG4gICAgICB0aGlzLnByb3BzLm9uVG91Y2hUYXBZZWFyKCk7XG5cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucHJvcHMuZGlzYWJsZVllYXJTZWxlY3Rpb24pIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe3NlbGVjdGVkWWVhcjogdHJ1ZX0pO1xuICAgIH1cbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgRGF0ZVRpbWVGb3JtYXQsXG4gICAgICBkaXNhYmxlWWVhclNlbGVjdGlvbiwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgbG9jYWxlLFxuICAgICAgbW9kZSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgbW9udGhEYXlTZWxlY3RlZCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgb25Ub3VjaFRhcE1vbnRoRGF5LCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBvblRvdWNoVGFwWWVhciwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgc2VsZWN0ZWREYXRlLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBzdHlsZSxcbiAgICAgIC4uLm90aGVyXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCB7cHJlcGFyZVN0eWxlc30gPSB0aGlzLmNvbnRleHQubXVpVGhlbWU7XG4gICAgY29uc3Qgc3R5bGVzID0gZ2V0U3R5bGVzKHRoaXMucHJvcHMsIHRoaXMuY29udGV4dCwgdGhpcy5zdGF0ZSk7XG5cbiAgICBjb25zdCB5ZWFyID0gbmV3IERhdGVUaW1lRm9ybWF0KGxvY2FsZSwge1xuICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgIH0pLmZvcm1hdChzZWxlY3RlZERhdGUpO1xuXG4gICAgY29uc3QgZGF0ZVRpbWUgPSBuZXcgRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCB7XG4gICAgICBtb250aDogJ3Nob3J0JyxcbiAgICAgIHdlZWtkYXk6ICdzaG9ydCcsXG4gICAgICBkYXk6ICcyLWRpZ2l0JyxcbiAgICB9KS5mb3JtYXQoc2VsZWN0ZWREYXRlKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IHsuLi5vdGhlcn0gc3R5bGU9e3ByZXBhcmVTdHlsZXMoc3R5bGVzLnJvb3QsIHN0eWxlKX0+XG4gICAgICAgIDxTbGlkZUluVHJhbnNpdGlvbkdyb3VwIHN0eWxlPXtzdHlsZXMueWVhcn0gZGlyZWN0aW9uPXt0aGlzLnN0YXRlLnRyYW5zaXRpb25EaXJlY3Rpb259PlxuICAgICAgICAgIDxkaXYga2V5PXt5ZWFyfSBzdHlsZT17c3R5bGVzLnllYXJUaXRsZX0gb25Ub3VjaFRhcD17dGhpcy5oYW5kbGVUb3VjaFRhcFllYXJ9PlxuICAgICAgICAgICAge3llYXJ9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvU2xpZGVJblRyYW5zaXRpb25Hcm91cD5cbiAgICAgICAgPFNsaWRlSW5UcmFuc2l0aW9uR3JvdXAgc3R5bGU9e3N0eWxlcy5tb250aERheX0gZGlyZWN0aW9uPXt0aGlzLnN0YXRlLnRyYW5zaXRpb25EaXJlY3Rpb259PlxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGtleT17ZGF0ZVRpbWV9XG4gICAgICAgICAgICBvblRvdWNoVGFwPXt0aGlzLmhhbmRsZVRvdWNoVGFwTW9udGhEYXl9XG4gICAgICAgICAgICBzdHlsZT17c3R5bGVzLm1vbnRoRGF5VGl0bGV9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2RhdGVUaW1lfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L1NsaWRlSW5UcmFuc2l0aW9uR3JvdXA+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERhdGVEaXNwbGF5O1xuIl19