'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactEventListener = require('react-event-listener');

var _reactEventListener2 = _interopRequireDefault(_reactEventListener);

var _keycode = require('keycode');

var _keycode2 = _interopRequireDefault(_keycode);

var _transitions = require('../styles/transitions');

var _transitions2 = _interopRequireDefault(_transitions);

var _CalendarActionButtons = require('./CalendarActionButtons');

var _CalendarActionButtons2 = _interopRequireDefault(_CalendarActionButtons);

var _CalendarMonth = require('./CalendarMonth');

var _CalendarMonth2 = _interopRequireDefault(_CalendarMonth);

var _CalendarYear = require('./CalendarYear');

var _CalendarYear2 = _interopRequireDefault(_CalendarYear);

var _CalendarToolbar = require('./CalendarToolbar');

var _CalendarToolbar2 = _interopRequireDefault(_CalendarToolbar);

var _DateDisplay = require('./DateDisplay');

var _DateDisplay2 = _interopRequireDefault(_DateDisplay);

var _SlideIn = require('../internal/SlideIn');

var _SlideIn2 = _interopRequireDefault(_SlideIn);

var _dateUtils = require('./dateUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var daysArray = [].concat(_toConsumableArray(Array(7)));

var Calendar = function (_Component) {
  _inherits(Calendar, _Component);

  function Calendar() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Calendar);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Calendar.__proto__ || Object.getPrototypeOf(Calendar)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      displayDate: undefined,
      displayMonthDay: true,
      selectedDate: undefined,
      transitionDirection: 'left',
      transitionEnter: true
    }, _this.handleTouchTapDay = function (event, date) {
      _this.setSelectedDate(date);
      if (_this.props.onTouchTapDay) _this.props.onTouchTapDay(event, date);
    }, _this.handleMonthChange = function (months) {
      _this.setState({
        transitionDirection: months >= 0 ? 'left' : 'right',
        displayDate: (0, _dateUtils.addMonths)(_this.state.displayDate, months)
      });
    }, _this.handleTouchTapYear = function (event, year) {
      var date = (0, _dateUtils.cloneDate)(_this.state.selectedDate);
      date.setFullYear(year);
      _this.setSelectedDate(date, event);

      console.log('----->>>');

      _this.handleTouchTapDateDisplayYear();
    }, _this.handleTouchTapDateDisplayMonthDay = function () {
      _this.setState({
        displayMonthDay: true
      });
    }, _this.handleTouchTapDateDisplayYear = function () {

      _this.setState({
        //  displayMonthDay: false,
        displayMonthDay: !_this.state.displayMonthDay
      });
    }, _this.handleWindowKeyDown = function (event) {
      if (_this.props.open) {
        switch ((0, _keycode2.default)(event)) {
          case 'up':
            if (event.altKey && event.shiftKey) {
              _this.addSelectedYears(-1);
            } else if (event.shiftKey) {
              _this.addSelectedMonths(-1);
            } else {
              _this.addSelectedDays(-7);
            }
            break;

          case 'down':
            if (event.altKey && event.shiftKey) {
              _this.addSelectedYears(1);
            } else if (event.shiftKey) {
              _this.addSelectedMonths(1);
            } else {
              _this.addSelectedDays(7);
            }
            break;

          case 'right':
            if (event.altKey && event.shiftKey) {
              _this.addSelectedYears(1);
            } else if (event.shiftKey) {
              _this.addSelectedMonths(1);
            } else {
              _this.addSelectedDays(1);
            }
            break;

          case 'left':
            if (event.altKey && event.shiftKey) {
              _this.addSelectedYears(-1);
            } else if (event.shiftKey) {
              _this.addSelectedMonths(-1);
            } else {
              _this.addSelectedDays(-1);
            }
            break;
        }
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Calendar, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.setState({
        displayDate: (0, _dateUtils.getFirstDayOfMonth)(this.props.initialDate),
        selectedDate: this.props.initialDate
      });
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.initialDate !== this.props.initialDate) {
        var date = nextProps.initialDate || new Date();
        this.setState({
          displayDate: (0, _dateUtils.getFirstDayOfMonth)(date),
          selectedDate: date
        });
      }
    }
  }, {
    key: 'getSelectedDate',
    value: function getSelectedDate() {
      return this.state.selectedDate;
    }
  }, {
    key: 'isSelectedDateDisabled',
    value: function isSelectedDateDisabled() {
      if (!this.state.displayMonthDay) {
        return false;
      }

      return this.refs.calendar.isSelectedDateDisabled();
    }
  }, {
    key: 'addSelectedDays',
    value: function addSelectedDays(days) {
      this.setSelectedDate((0, _dateUtils.addDays)(this.state.selectedDate, days));
    }
  }, {
    key: 'addSelectedMonths',
    value: function addSelectedMonths(months) {
      this.setSelectedDate((0, _dateUtils.addMonths)(this.state.selectedDate, months));
    }
  }, {
    key: 'addSelectedYears',
    value: function addSelectedYears(years) {
      this.setSelectedDate((0, _dateUtils.addYears)(this.state.selectedDate, years));
    }
  }, {
    key: 'setDisplayDate',
    value: function setDisplayDate(date, newSelectedDate) {
      var newDisplayDate = (0, _dateUtils.getFirstDayOfMonth)(date);
      var direction = newDisplayDate > this.state.displayDate ? 'left' : 'right';

      if (newDisplayDate !== this.state.displayDate) {
        this.setState({
          displayDate: newDisplayDate,
          transitionDirection: direction,
          selectedDate: newSelectedDate || this.state.selectedDate
        });
      }
    }
  }, {
    key: 'setSelectedDate',
    value: function setSelectedDate(date) {
      var adjustedDate = date;
      if ((0, _dateUtils.isBeforeDate)(date, this.props.minDate)) {
        adjustedDate = this.props.minDate;
      } else if ((0, _dateUtils.isAfterDate)(date, this.props.maxDate)) {
        adjustedDate = this.props.maxDate;
      }

      var newDisplayDate = (0, _dateUtils.getFirstDayOfMonth)(adjustedDate);
      if (newDisplayDate !== this.state.displayDate) {
        this.setDisplayDate(newDisplayDate, adjustedDate);
      } else {
        this.setState({
          selectedDate: adjustedDate
        });
      }
    }
  }, {
    key: 'getToolbarInteractions',
    value: function getToolbarInteractions() {
      return {
        prevMonth: (0, _dateUtils.monthDiff)(this.state.displayDate, this.props.minDate) > 0,
        nextMonth: (0, _dateUtils.monthDiff)(this.state.displayDate, this.props.maxDate) < 0
      };
    }
  }, {
    key: 'yearSelector',
    value: function yearSelector() {
      if (!this.props.disableYearSelection) {
        return _react2.default.createElement(_CalendarYear2.default, {
          key: 'years',
          DateTimeFormat: this.props.DateTimeFormat,
          locale: this.props.locale,
          onTouchTapYear: this.handleTouchTapYear,
          selectedDate: this.state.selectedDate,
          minDate: this.props.minDate,
          maxDate: this.props.maxDate
        });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var prepareStyles = this.context.muiTheme.prepareStyles;

      var toolbarInteractions = this.getToolbarInteractions();
      var isLandscape = this.props.mode === 'landscape';
      var calendarTextColor = this.context.muiTheme.datePicker.calendarTextColor;


      var styles = {
        root: {
          color: calendarTextColor,
          userSelect: 'none',
          width: isLandscape ? 479 : 310
        },
        calendar: {
          display: 'flex',
          flexDirection: 'column'
        },
        calendarContainer: {
          display: 'flex',
          alignContent: 'space-between',
          justifyContent: 'space-between',
          flexDirection: 'column',
          fontSize: 12,
          fontWeight: 400,
          padding: '0px 8px',
          transition: _transitions2.default.easeOut()
        },
        yearContainer: {
          display: 'flex',
          justifyContent: 'space-between',
          flexDirection: 'column',
          height: 272,
          marginTop: 10,
          overflow: 'hidden',
          width: 310
        },
        weekTitle: {
          display: 'flex',
          flexDirection: 'row',
          justifyContent: 'space-between',
          fontWeight: '500',
          height: 20,
          lineHeight: '15px',
          opacity: '0.5',
          textAlign: 'center'
        },
        weekTitleDay: {
          width: 42
        },
        transitionSlide: {
          height: 214
        }
      };

      var weekTitleDayStyle = prepareStyles(styles.weekTitleDay);

      var _props = this.props,
          minDate = _props.minDate,
          maxDate = _props.maxDate,
          cancelLabel = _props.cancelLabel,
          DateTimeFormat = _props.DateTimeFormat,
          firstDayOfWeek = _props.firstDayOfWeek,
          locale = _props.locale,
          okLabel = _props.okLabel,
          onTouchTapCancel = _props.onTouchTapCancel,
          onTouchTapOk = _props.onTouchTapOk;


      return _react2.default.createElement(
        'div',
        { style: prepareStyles(styles.root) },
        _react2.default.createElement(_reactEventListener2.default, {
          target: 'window',
          onKeyDown: this.handleWindowKeyDown
        }),
        _react2.default.createElement(
          'div',
          { style: prepareStyles(styles.calendar) },
          this.state.displayMonthDay && _react2.default.createElement(
            'div',
            { style: prepareStyles(styles.calendarContainer) },
            _react2.default.createElement(_CalendarToolbar2.default, {
              DateTimeFormat: DateTimeFormat,
              locale: locale,
              displayDate: this.state.displayDate,
              onMonthChange: this.handleMonthChange,
              prevMonth: toolbarInteractions.prevMonth,
              nextMonth: toolbarInteractions.nextMonth,
              onTouchTapYear: this.handleTouchTapDateDisplayYear
            }),
            _react2.default.createElement(
              'div',
              { style: prepareStyles(styles.weekTitle) },
              daysArray.map(function (event, i) {
                return _react2.default.createElement(
                  'span',
                  { key: i, style: weekTitleDayStyle },
                  (0, _dateUtils.localizedWeekday)(DateTimeFormat, locale, i, firstDayOfWeek)
                );
              })
            ),
            _react2.default.createElement(
              _SlideIn2.default,
              { direction: this.state.transitionDirection, style: styles.transitionSlide },
              _react2.default.createElement(_CalendarMonth2.default, {
                DateTimeFormat: DateTimeFormat,
                locale: locale,
                displayDate: this.state.displayDate,
                firstDayOfWeek: this.props.firstDayOfWeek,
                key: this.state.displayDate.toDateString(),
                minDate: minDate,
                maxDate: maxDate,
                onTouchTapDay: this.handleTouchTapDay,
                ref: 'calendar',
                selectedDate: this.state.selectedDate,
                shouldDisableDate: this.props.shouldDisableDate
              })
            )
          ),
          !this.state.displayMonthDay && _react2.default.createElement(
            'div',
            { style: prepareStyles(styles.yearContainer) },
            this.yearSelector()
          )
        )
      );
    }
  }]);

  return Calendar;
}(_react.Component);

Calendar.propTypes = {
  DateTimeFormat: _react.PropTypes.func.isRequired,
  autoOk: _react.PropTypes.bool,
  cancelLabel: _react.PropTypes.node,
  disableYearSelection: _react.PropTypes.bool,
  firstDayOfWeek: _react.PropTypes.number,
  initialDate: _react.PropTypes.object,
  locale: _react.PropTypes.string.isRequired,
  maxDate: _react.PropTypes.object,
  minDate: _react.PropTypes.object,
  mode: _react.PropTypes.oneOf(['portrait', 'landscape']),
  okLabel: _react.PropTypes.node,
  onTouchTapCancel: _react.PropTypes.func,
  onTouchTapDay: _react.PropTypes.func,
  onTouchTapOk: _react.PropTypes.func,
  open: _react.PropTypes.bool,
  shouldDisableDate: _react.PropTypes.func
};
Calendar.defaultProps = {
  DateTimeFormat: _dateUtils.dateTimeFormat,
  disableYearSelection: false,
  initialDate: new Date(),
  locale: 'en-US',
  minDate: (0, _dateUtils.addYears)(new Date(), -100),
  maxDate: (0, _dateUtils.addYears)(new Date(), 100)
};
Calendar.contextTypes = {
  muiTheme: _react.PropTypes.object.isRequired
};
var _default = Calendar;
exports.default = _default;
;

var _temp2 = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(daysArray, 'daysArray', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/DatePicker/Calendar.js');

  __REACT_HOT_LOADER__.register(Calendar, 'Calendar', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/DatePicker/Calendar.js');

  __REACT_HOT_LOADER__.register(_default, 'default', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/DatePicker/Calendar.js');
}();

;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9Db21wb25lbnRzL0RhdGVQaWNrZXIvRGF0ZVBpY2tlci9DYWxlbmRhci5qcyJdLCJuYW1lcyI6WyJkYXlzQXJyYXkiLCJBcnJheSIsIkNhbGVuZGFyIiwic3RhdGUiLCJkaXNwbGF5RGF0ZSIsInVuZGVmaW5lZCIsImRpc3BsYXlNb250aERheSIsInNlbGVjdGVkRGF0ZSIsInRyYW5zaXRpb25EaXJlY3Rpb24iLCJ0cmFuc2l0aW9uRW50ZXIiLCJoYW5kbGVUb3VjaFRhcERheSIsImV2ZW50IiwiZGF0ZSIsInNldFNlbGVjdGVkRGF0ZSIsInByb3BzIiwib25Ub3VjaFRhcERheSIsImhhbmRsZU1vbnRoQ2hhbmdlIiwibW9udGhzIiwic2V0U3RhdGUiLCJoYW5kbGVUb3VjaFRhcFllYXIiLCJ5ZWFyIiwic2V0RnVsbFllYXIiLCJjb25zb2xlIiwibG9nIiwiaGFuZGxlVG91Y2hUYXBEYXRlRGlzcGxheVllYXIiLCJoYW5kbGVUb3VjaFRhcERhdGVEaXNwbGF5TW9udGhEYXkiLCJoYW5kbGVXaW5kb3dLZXlEb3duIiwib3BlbiIsImFsdEtleSIsInNoaWZ0S2V5IiwiYWRkU2VsZWN0ZWRZZWFycyIsImFkZFNlbGVjdGVkTW9udGhzIiwiYWRkU2VsZWN0ZWREYXlzIiwiaW5pdGlhbERhdGUiLCJuZXh0UHJvcHMiLCJEYXRlIiwicmVmcyIsImNhbGVuZGFyIiwiaXNTZWxlY3RlZERhdGVEaXNhYmxlZCIsImRheXMiLCJ5ZWFycyIsIm5ld1NlbGVjdGVkRGF0ZSIsIm5ld0Rpc3BsYXlEYXRlIiwiZGlyZWN0aW9uIiwiYWRqdXN0ZWREYXRlIiwibWluRGF0ZSIsIm1heERhdGUiLCJzZXREaXNwbGF5RGF0ZSIsInByZXZNb250aCIsIm5leHRNb250aCIsImRpc2FibGVZZWFyU2VsZWN0aW9uIiwiRGF0ZVRpbWVGb3JtYXQiLCJsb2NhbGUiLCJwcmVwYXJlU3R5bGVzIiwiY29udGV4dCIsIm11aVRoZW1lIiwidG9vbGJhckludGVyYWN0aW9ucyIsImdldFRvb2xiYXJJbnRlcmFjdGlvbnMiLCJpc0xhbmRzY2FwZSIsIm1vZGUiLCJjYWxlbmRhclRleHRDb2xvciIsImRhdGVQaWNrZXIiLCJzdHlsZXMiLCJyb290IiwiY29sb3IiLCJ1c2VyU2VsZWN0Iiwid2lkdGgiLCJkaXNwbGF5IiwiZmxleERpcmVjdGlvbiIsImNhbGVuZGFyQ29udGFpbmVyIiwiYWxpZ25Db250ZW50IiwianVzdGlmeUNvbnRlbnQiLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJwYWRkaW5nIiwidHJhbnNpdGlvbiIsImVhc2VPdXQiLCJ5ZWFyQ29udGFpbmVyIiwiaGVpZ2h0IiwibWFyZ2luVG9wIiwib3ZlcmZsb3ciLCJ3ZWVrVGl0bGUiLCJsaW5lSGVpZ2h0Iiwib3BhY2l0eSIsInRleHRBbGlnbiIsIndlZWtUaXRsZURheSIsInRyYW5zaXRpb25TbGlkZSIsIndlZWtUaXRsZURheVN0eWxlIiwiY2FuY2VsTGFiZWwiLCJmaXJzdERheU9mV2VlayIsIm9rTGFiZWwiLCJvblRvdWNoVGFwQ2FuY2VsIiwib25Ub3VjaFRhcE9rIiwibWFwIiwiaSIsInRvRGF0ZVN0cmluZyIsInNob3VsZERpc2FibGVEYXRlIiwieWVhclNlbGVjdG9yIiwicHJvcFR5cGVzIiwiZnVuYyIsImlzUmVxdWlyZWQiLCJhdXRvT2siLCJib29sIiwibm9kZSIsIm51bWJlciIsIm9iamVjdCIsInN0cmluZyIsIm9uZU9mIiwiZGVmYXVsdFByb3BzIiwiY29udGV4dFR5cGVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7Ozs7Ozs7OztBQWFBLElBQU1BLHlDQUFnQkMsTUFBTSxDQUFOLENBQWhCLEVBQU47O0lBRU1DLFE7Ozs7Ozs7Ozs7Ozs7OzBMQWlDSkMsSyxHQUFRO0FBQ05DLG1CQUFhQyxTQURQO0FBRU5DLHVCQUFpQixJQUZYO0FBR05DLG9CQUFjRixT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LFE7Ozs7Ozs7OztnQ0F6WFRGLFM7O2dDQUVBRSxRIiwiZmlsZSI6IkNhbGVuZGFyLmpzIiwic291cmNlUm9vdCI6Ii9Vc2Vycy90bWFjX3pjL0NvZGUva3ItYWRtaW4iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHtDb21wb25lbnQsIFByb3BUeXBlc30gZnJvbSAncmVhY3QnO1xuaW1wb3J0IEV2ZW50TGlzdGVuZXIgZnJvbSAncmVhY3QtZXZlbnQtbGlzdGVuZXInO1xuaW1wb3J0IGtleWNvZGUgZnJvbSAna2V5Y29kZSc7XG5pbXBvcnQgdHJhbnNpdGlvbnMgZnJvbSAnLi4vc3R5bGVzL3RyYW5zaXRpb25zJztcbmltcG9ydCBDYWxlbmRhckFjdGlvbkJ1dHRvbnMgZnJvbSAnLi9DYWxlbmRhckFjdGlvbkJ1dHRvbnMnO1xuaW1wb3J0IENhbGVuZGFyTW9udGggZnJvbSAnLi9DYWxlbmRhck1vbnRoJztcbmltcG9ydCBDYWxlbmRhclllYXIgZnJvbSAnLi9DYWxlbmRhclllYXInO1xuaW1wb3J0IENhbGVuZGFyVG9vbGJhciBmcm9tICcuL0NhbGVuZGFyVG9vbGJhcic7XG5pbXBvcnQgRGF0ZURpc3BsYXkgZnJvbSAnLi9EYXRlRGlzcGxheSc7XG5pbXBvcnQgU2xpZGVJblRyYW5zaXRpb25Hcm91cCBmcm9tICcuLi9pbnRlcm5hbC9TbGlkZUluJztcblxuaW1wb3J0IHtcbiAgYWRkRGF5cyxcbiAgYWRkTW9udGhzLFxuICBhZGRZZWFycyxcbiAgY2xvbmVEYXRlLFxuICBkYXRlVGltZUZvcm1hdCxcbiAgaXNBZnRlckRhdGUsXG4gIGlzQmVmb3JlRGF0ZSxcbiAgZ2V0Rmlyc3REYXlPZk1vbnRoLFxuICBsb2NhbGl6ZWRXZWVrZGF5LFxuICBtb250aERpZmYsXG59IGZyb20gJy4vZGF0ZVV0aWxzJztcblxuY29uc3QgZGF5c0FycmF5ID0gWy4uLkFycmF5KDcpXTtcblxuY2xhc3MgQ2FsZW5kYXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIERhdGVUaW1lRm9ybWF0OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIGF1dG9PazogUHJvcFR5cGVzLmJvb2wsXG4gICAgY2FuY2VsTGFiZWw6IFByb3BUeXBlcy5ub2RlLFxuICAgIGRpc2FibGVZZWFyU2VsZWN0aW9uOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBmaXJzdERheU9mV2VlazogUHJvcFR5cGVzLm51bWJlcixcbiAgICBpbml0aWFsRGF0ZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBsb2NhbGU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBtYXhEYXRlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIG1pbkRhdGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgbW9kZTogUHJvcFR5cGVzLm9uZU9mKFsncG9ydHJhaXQnLCAnbGFuZHNjYXBlJ10pLFxuICAgIG9rTGFiZWw6IFByb3BUeXBlcy5ub2RlLFxuICAgIG9uVG91Y2hUYXBDYW5jZWw6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uVG91Y2hUYXBEYXk6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uVG91Y2hUYXBPazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb3BlbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgc2hvdWxkRGlzYWJsZURhdGU6IFByb3BUeXBlcy5mdW5jLFxuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgRGF0ZVRpbWVGb3JtYXQ6IGRhdGVUaW1lRm9ybWF0LFxuICAgIGRpc2FibGVZZWFyU2VsZWN0aW9uOiBmYWxzZSxcbiAgICBpbml0aWFsRGF0ZTogbmV3IERhdGUoKSxcbiAgICBsb2NhbGU6ICdlbi1VUycsXG4gICAgbWluRGF0ZTogYWRkWWVhcnMobmV3IERhdGUoKSwgLTEwMCksXG4gICAgbWF4RGF0ZTogYWRkWWVhcnMobmV3IERhdGUoKSwgMTAwKSxcbiAgfTtcblxuICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgIG11aVRoZW1lOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIH07XG5cbiAgc3RhdGUgPSB7XG4gICAgZGlzcGxheURhdGU6IHVuZGVmaW5lZCxcbiAgICBkaXNwbGF5TW9udGhEYXk6IHRydWUsXG4gICAgc2VsZWN0ZWREYXRlOiB1bmRlZmluZWQsXG4gICAgdHJhbnNpdGlvbkRpcmVjdGlvbjogJ2xlZnQnLFxuICAgIHRyYW5zaXRpb25FbnRlcjogdHJ1ZSxcbiAgfTtcblxuICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBkaXNwbGF5RGF0ZTogZ2V0Rmlyc3REYXlPZk1vbnRoKHRoaXMucHJvcHMuaW5pdGlhbERhdGUpLFxuICAgICAgc2VsZWN0ZWREYXRlOiB0aGlzLnByb3BzLmluaXRpYWxEYXRlLFxuICAgIH0pO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLmluaXRpYWxEYXRlICE9PSB0aGlzLnByb3BzLmluaXRpYWxEYXRlKSB7XG4gICAgICBjb25zdCBkYXRlID0gbmV4dFByb3BzLmluaXRpYWxEYXRlIHx8IG5ldyBEYXRlKCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZGlzcGxheURhdGU6IGdldEZpcnN0RGF5T2ZNb250aChkYXRlKSxcbiAgICAgICAgc2VsZWN0ZWREYXRlOiBkYXRlLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0U2VsZWN0ZWREYXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGVkRGF0ZTtcbiAgfVxuXG4gIGlzU2VsZWN0ZWREYXRlRGlzYWJsZWQoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLmRpc3BsYXlNb250aERheSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlZnMuY2FsZW5kYXIuaXNTZWxlY3RlZERhdGVEaXNhYmxlZCgpO1xuICB9XG5cbiAgYWRkU2VsZWN0ZWREYXlzKGRheXMpIHtcbiAgICB0aGlzLnNldFNlbGVjdGVkRGF0ZShhZGREYXlzKHRoaXMuc3RhdGUuc2VsZWN0ZWREYXRlLCBkYXlzKSk7XG4gIH1cblxuICBhZGRTZWxlY3RlZE1vbnRocyhtb250aHMpIHtcbiAgICB0aGlzLnNldFNlbGVjdGVkRGF0ZShhZGRNb250aHModGhpcy5zdGF0ZS5zZWxlY3RlZERhdGUsIG1vbnRocykpO1xuICB9XG5cbiAgYWRkU2VsZWN0ZWRZZWFycyh5ZWFycykge1xuICAgIHRoaXMuc2V0U2VsZWN0ZWREYXRlKGFkZFllYXJzKHRoaXMuc3RhdGUuc2VsZWN0ZWREYXRlLCB5ZWFycykpO1xuICB9XG5cbiAgc2V0RGlzcGxheURhdGUoZGF0ZSwgbmV3U2VsZWN0ZWREYXRlKSB7XG4gICAgY29uc3QgbmV3RGlzcGxheURhdGUgPSBnZXRGaXJzdERheU9mTW9udGgoZGF0ZSk7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3RGlzcGxheURhdGUgPiB0aGlzLnN0YXRlLmRpc3BsYXlEYXRlID8gJ2xlZnQnIDogJ3JpZ2h0JztcblxuICAgIGlmIChuZXdEaXNwbGF5RGF0ZSAhPT0gdGhpcy5zdGF0ZS5kaXNwbGF5RGF0ZSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGRpc3BsYXlEYXRlOiBuZXdEaXNwbGF5RGF0ZSxcbiAgICAgICAgdHJhbnNpdGlvbkRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgICBzZWxlY3RlZERhdGU6IG5ld1NlbGVjdGVkRGF0ZSB8fCB0aGlzLnN0YXRlLnNlbGVjdGVkRGF0ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHNldFNlbGVjdGVkRGF0ZShkYXRlKSB7XG4gICAgbGV0IGFkanVzdGVkRGF0ZSA9IGRhdGU7XG4gICAgaWYgKGlzQmVmb3JlRGF0ZShkYXRlLCB0aGlzLnByb3BzLm1pbkRhdGUpKSB7XG4gICAgICBhZGp1c3RlZERhdGUgPSB0aGlzLnByb3BzLm1pbkRhdGU7XG4gICAgfSBlbHNlIGlmIChpc0FmdGVyRGF0ZShkYXRlLCB0aGlzLnByb3BzLm1heERhdGUpKSB7XG4gICAgICBhZGp1c3RlZERhdGUgPSB0aGlzLnByb3BzLm1heERhdGU7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3RGlzcGxheURhdGUgPSBnZXRGaXJzdERheU9mTW9udGgoYWRqdXN0ZWREYXRlKTtcbiAgICBpZiAobmV3RGlzcGxheURhdGUgIT09IHRoaXMuc3RhdGUuZGlzcGxheURhdGUpIHtcbiAgICAgIHRoaXMuc2V0RGlzcGxheURhdGUobmV3RGlzcGxheURhdGUsIGFkanVzdGVkRGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBzZWxlY3RlZERhdGU6IGFkanVzdGVkRGF0ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVRvdWNoVGFwRGF5ID0gKGV2ZW50LCBkYXRlKSA9PiB7XG4gICAgdGhpcy5zZXRTZWxlY3RlZERhdGUoZGF0ZSk7XG4gICAgaWYgKHRoaXMucHJvcHMub25Ub3VjaFRhcERheSkgdGhpcy5wcm9wcy5vblRvdWNoVGFwRGF5KGV2ZW50LCBkYXRlKTtcbiAgfTtcblxuICBoYW5kbGVNb250aENoYW5nZSA9IChtb250aHMpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHRyYW5zaXRpb25EaXJlY3Rpb246IG1vbnRocyA+PSAwID8gJ2xlZnQnIDogJ3JpZ2h0JyxcbiAgICAgIGRpc3BsYXlEYXRlOiBhZGRNb250aHModGhpcy5zdGF0ZS5kaXNwbGF5RGF0ZSwgbW9udGhzKSxcbiAgICB9KTtcbiAgfTtcblxuICBoYW5kbGVUb3VjaFRhcFllYXIgPSAoZXZlbnQsIHllYXIpID0+IHtcbiAgICBjb25zdCBkYXRlID0gY2xvbmVEYXRlKHRoaXMuc3RhdGUuc2VsZWN0ZWREYXRlKTtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKHllYXIpO1xuICAgIHRoaXMuc2V0U2VsZWN0ZWREYXRlKGRhdGUsIGV2ZW50KTtcblxuICAgIGNvbnNvbGUubG9nKCctLS0tLT4+PicpXG5cbiAgICB0aGlzLmhhbmRsZVRvdWNoVGFwRGF0ZURpc3BsYXlZZWFyKCk7XG4gIH07XG5cbiAgZ2V0VG9vbGJhckludGVyYWN0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJldk1vbnRoOiBtb250aERpZmYodGhpcy5zdGF0ZS5kaXNwbGF5RGF0ZSwgdGhpcy5wcm9wcy5taW5EYXRlKSA+IDAsXG4gICAgICBuZXh0TW9udGg6IG1vbnRoRGlmZih0aGlzLnN0YXRlLmRpc3BsYXlEYXRlLCB0aGlzLnByb3BzLm1heERhdGUpIDwgMCxcbiAgICB9O1xuICB9XG5cbiAgaGFuZGxlVG91Y2hUYXBEYXRlRGlzcGxheU1vbnRoRGF5ID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZGlzcGxheU1vbnRoRGF5OiB0cnVlLFxuICAgIH0pO1xuICB9O1xuXG4gIGhhbmRsZVRvdWNoVGFwRGF0ZURpc3BsYXlZZWFyID0gKCkgPT4ge1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgLy8gIGRpc3BsYXlNb250aERheTogZmFsc2UsXG4gICAgICAgIGRpc3BsYXlNb250aERheTohdGhpcy5zdGF0ZS5kaXNwbGF5TW9udGhEYXlcbiAgICB9KTtcbiAgfTtcblxuICBoYW5kbGVXaW5kb3dLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMub3Blbikge1xuICAgICAgc3dpdGNoIChrZXljb2RlKGV2ZW50KSkge1xuICAgICAgICBjYXNlICd1cCc6XG4gICAgICAgICAgaWYgKGV2ZW50LmFsdEtleSAmJiBldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgdGhpcy5hZGRTZWxlY3RlZFllYXJzKC0xKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICB0aGlzLmFkZFNlbGVjdGVkTW9udGhzKC0xKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRTZWxlY3RlZERheXMoLTcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkb3duJzpcbiAgICAgICAgICBpZiAoZXZlbnQuYWx0S2V5ICYmIGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICB0aGlzLmFkZFNlbGVjdGVkWWVhcnMoMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgdGhpcy5hZGRTZWxlY3RlZE1vbnRocygxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRTZWxlY3RlZERheXMoNyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBpZiAoZXZlbnQuYWx0S2V5ICYmIGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICB0aGlzLmFkZFNlbGVjdGVkWWVhcnMoMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgdGhpcy5hZGRTZWxlY3RlZE1vbnRocygxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRTZWxlY3RlZERheXMoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIGlmIChldmVudC5hbHRLZXkgJiYgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU2VsZWN0ZWRZZWFycygtMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgdGhpcy5hZGRTZWxlY3RlZE1vbnRocygtMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU2VsZWN0ZWREYXlzKC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHllYXJTZWxlY3RvcigpIHtcbiAgICBpZiAoIXRoaXMucHJvcHMuZGlzYWJsZVllYXJTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxDYWxlbmRhclllYXJcbiAgICAgICAgICBrZXk9XCJ5ZWFyc1wiXG4gICAgICAgICAgRGF0ZVRpbWVGb3JtYXQ9e3RoaXMucHJvcHMuRGF0ZVRpbWVGb3JtYXR9XG4gICAgICAgICAgbG9jYWxlPXt0aGlzLnByb3BzLmxvY2FsZX1cbiAgICAgICAgICBvblRvdWNoVGFwWWVhcj17dGhpcy5oYW5kbGVUb3VjaFRhcFllYXJ9XG4gICAgICAgICAgc2VsZWN0ZWREYXRlPXt0aGlzLnN0YXRlLnNlbGVjdGVkRGF0ZX1cbiAgICAgICAgICBtaW5EYXRlPXt0aGlzLnByb3BzLm1pbkRhdGV9XG4gICAgICAgICAgbWF4RGF0ZT17dGhpcy5wcm9wcy5tYXhEYXRlfVxuICAgICAgICAvPlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge3ByZXBhcmVTdHlsZXN9ID0gdGhpcy5jb250ZXh0Lm11aVRoZW1lO1xuICAgIGNvbnN0IHRvb2xiYXJJbnRlcmFjdGlvbnMgPSB0aGlzLmdldFRvb2xiYXJJbnRlcmFjdGlvbnMoKTtcbiAgICBjb25zdCBpc0xhbmRzY2FwZSA9IHRoaXMucHJvcHMubW9kZSA9PT0gJ2xhbmRzY2FwZSc7XG4gICAgY29uc3Qge2NhbGVuZGFyVGV4dENvbG9yfSA9IHRoaXMuY29udGV4dC5tdWlUaGVtZS5kYXRlUGlja2VyO1xuXG4gICAgY29uc3Qgc3R5bGVzID0ge1xuICAgICAgcm9vdDoge1xuICAgICAgICBjb2xvcjogY2FsZW5kYXJUZXh0Q29sb3IsXG4gICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgd2lkdGg6IGlzTGFuZHNjYXBlID8gNDc5IDogMzEwLFxuICAgICAgfSxcbiAgICAgIGNhbGVuZGFyOiB7XG4gICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICB9LFxuICAgICAgY2FsZW5kYXJDb250YWluZXI6IHtcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICBhbGlnbkNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJyxcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJyxcbiAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgZm9udFdlaWdodDogNDAwLFxuICAgICAgICBwYWRkaW5nOiAnMHB4IDhweCcsXG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb25zLmVhc2VPdXQoKSxcbiAgICAgIH0sXG4gICAgICB5ZWFyQ29udGFpbmVyOiB7XG4gICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJyxcbiAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgIGhlaWdodDogMjcyLFxuICAgICAgICBtYXJnaW5Ub3A6IDEwLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIHdpZHRoOiAzMTAsXG4gICAgICB9LFxuICAgICAgd2Vla1RpdGxlOiB7XG4gICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgZmxleERpcmVjdGlvbjogJ3JvdycsXG4gICAgICAgIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYmV0d2VlbicsXG4gICAgICAgIGZvbnRXZWlnaHQ6ICc1MDAnLFxuICAgICAgICBoZWlnaHQ6IDIwLFxuICAgICAgICBsaW5lSGVpZ2h0OiAnMTVweCcsXG4gICAgICAgIG9wYWNpdHk6ICcwLjUnLFxuICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgfSxcbiAgICAgIHdlZWtUaXRsZURheToge1xuICAgICAgICB3aWR0aDogNDIsXG4gICAgICB9LFxuICAgICAgdHJhbnNpdGlvblNsaWRlOiB7XG4gICAgICAgIGhlaWdodDogMjE0LFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgY29uc3Qgd2Vla1RpdGxlRGF5U3R5bGUgPSBwcmVwYXJlU3R5bGVzKHN0eWxlcy53ZWVrVGl0bGVEYXkpO1xuXG4gICAgY29uc3Qge1xuICAgICAgbWluRGF0ZSxcbiAgICAgIG1heERhdGUsXG4gICAgICBjYW5jZWxMYWJlbCxcbiAgICAgIERhdGVUaW1lRm9ybWF0LFxuICAgICAgZmlyc3REYXlPZldlZWssXG4gICAgICBsb2NhbGUsXG4gICAgICBva0xhYmVsLFxuICAgICAgb25Ub3VjaFRhcENhbmNlbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgb25Ub3VjaFRhcE9rLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBzdHlsZT17cHJlcGFyZVN0eWxlcyhzdHlsZXMucm9vdCl9PlxuICAgICAgICA8RXZlbnRMaXN0ZW5lclxuICAgICAgICAgIHRhcmdldD1cIndpbmRvd1wiXG4gICAgICAgICAgb25LZXlEb3duPXt0aGlzLmhhbmRsZVdpbmRvd0tleURvd259XG4gICAgICAgIC8+XG5cbiAgICAgICAgey8qXG5cbiAgICAgICAgPERhdGVEaXNwbGF5XG4gICAgICAgICAgRGF0ZVRpbWVGb3JtYXQ9e0RhdGVUaW1lRm9ybWF0fVxuICAgICAgICAgIGRpc2FibGVZZWFyU2VsZWN0aW9uPXt0aGlzLnByb3BzLmRpc2FibGVZZWFyU2VsZWN0aW9ufVxuICAgICAgICAgIG9uVG91Y2hUYXBNb250aERheT17dGhpcy5oYW5kbGVUb3VjaFRhcERhdGVEaXNwbGF5TW9udGhEYXl9XG4gICAgICAgICAgb25Ub3VjaFRhcFllYXI9e3RoaXMuaGFuZGxlVG91Y2hUYXBEYXRlRGlzcGxheVllYXJ9XG4gICAgICAgICAgbG9jYWxlPXtsb2NhbGV9XG4gICAgICAgICAgbW9udGhEYXlTZWxlY3RlZD17dGhpcy5zdGF0ZS5kaXNwbGF5TW9udGhEYXl9XG4gICAgICAgICAgbW9kZT17dGhpcy5wcm9wcy5tb2RlfVxuICAgICAgICAgIHNlbGVjdGVkRGF0ZT17dGhpcy5zdGF0ZS5zZWxlY3RlZERhdGV9XG4gICAgICAgIC8+XG5cbiAgICAgICAgICAqL31cblxuICAgICAgICA8ZGl2IHN0eWxlPXtwcmVwYXJlU3R5bGVzKHN0eWxlcy5jYWxlbmRhcil9PlxuICAgICAgICAgIHt0aGlzLnN0YXRlLmRpc3BsYXlNb250aERheSAmJlxuICAgICAgICAgICAgPGRpdiBzdHlsZT17cHJlcGFyZVN0eWxlcyhzdHlsZXMuY2FsZW5kYXJDb250YWluZXIpfT5cbiAgICAgICAgICAgIHsvKlxuICAgICAgICAgICAgICA8Q2FsZW5kYXJUb29sYmFyXG4gICAgICAgICAgICAgICAgRGF0ZVRpbWVGb3JtYXQ9e0RhdGVUaW1lRm9ybWF0fVxuICAgICAgICAgICAgICAgIGxvY2FsZT17bG9jYWxlfVxuICAgICAgICAgICAgICAgIGRpc3BsYXlEYXRlPXt0aGlzLnN0YXRlLmRpc3BsYXlEYXRlfVxuICAgICAgICAgICAgICAgIG9uTW9udGhDaGFuZ2U9e3RoaXMuaGFuZGxlTW9udGhDaGFuZ2V9XG4gICAgICAgICAgICAgICAgcHJldk1vbnRoPXt0b29sYmFySW50ZXJhY3Rpb25zLnByZXZNb250aH1cbiAgICAgICAgICAgICAgICBuZXh0TW9udGg9e3Rvb2xiYXJJbnRlcmFjdGlvbnMubmV4dE1vbnRofVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAqL31cbiAgICAgICAgICAgICAgPENhbGVuZGFyVG9vbGJhclxuICAgICAgICAgICAgICAgIERhdGVUaW1lRm9ybWF0PXtEYXRlVGltZUZvcm1hdH1cbiAgICAgICAgICAgICAgICBsb2NhbGU9e2xvY2FsZX1cbiAgICAgICAgICAgICAgICBkaXNwbGF5RGF0ZT17dGhpcy5zdGF0ZS5kaXNwbGF5RGF0ZX1cbiAgICAgICAgICAgICAgICBvbk1vbnRoQ2hhbmdlPXt0aGlzLmhhbmRsZU1vbnRoQ2hhbmdlfVxuICAgICAgICAgICAgICAgIHByZXZNb250aD17dG9vbGJhckludGVyYWN0aW9ucy5wcmV2TW9udGh9XG4gICAgICAgICAgICAgICAgbmV4dE1vbnRoPXt0b29sYmFySW50ZXJhY3Rpb25zLm5leHRNb250aH1cbiAgICAgICAgICAgICAgICBvblRvdWNoVGFwWWVhcj17dGhpcy5oYW5kbGVUb3VjaFRhcERhdGVEaXNwbGF5WWVhcn1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPGRpdiBzdHlsZT17cHJlcGFyZVN0eWxlcyhzdHlsZXMud2Vla1RpdGxlKX0+XG4gICAgICAgICAgICAgICAge2RheXNBcnJheS5tYXAoKGV2ZW50LCBpKSA9PiAoXG4gICAgICAgICAgICAgICAgICA8c3BhbiBrZXk9e2l9IHN0eWxlPXt3ZWVrVGl0bGVEYXlTdHlsZX0+XG4gICAgICAgICAgICAgICAgICAgIHtsb2NhbGl6ZWRXZWVrZGF5KERhdGVUaW1lRm9ybWF0LCBsb2NhbGUsIGksIGZpcnN0RGF5T2ZXZWVrKX1cbiAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxTbGlkZUluVHJhbnNpdGlvbkdyb3VwIGRpcmVjdGlvbj17dGhpcy5zdGF0ZS50cmFuc2l0aW9uRGlyZWN0aW9ufSBzdHlsZT17c3R5bGVzLnRyYW5zaXRpb25TbGlkZX0+XG4gICAgICAgICAgICAgICAgPENhbGVuZGFyTW9udGhcbiAgICAgICAgICAgICAgICAgIERhdGVUaW1lRm9ybWF0PXtEYXRlVGltZUZvcm1hdH1cbiAgICAgICAgICAgICAgICAgIGxvY2FsZT17bG9jYWxlfVxuICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGU9e3RoaXMuc3RhdGUuZGlzcGxheURhdGV9XG4gICAgICAgICAgICAgICAgICBmaXJzdERheU9mV2Vlaz17dGhpcy5wcm9wcy5maXJzdERheU9mV2Vla31cbiAgICAgICAgICAgICAgICAgIGtleT17dGhpcy5zdGF0ZS5kaXNwbGF5RGF0ZS50b0RhdGVTdHJpbmcoKX1cbiAgICAgICAgICAgICAgICAgIG1pbkRhdGU9e21pbkRhdGV9XG4gICAgICAgICAgICAgICAgICBtYXhEYXRlPXttYXhEYXRlfVxuICAgICAgICAgICAgICAgICAgb25Ub3VjaFRhcERheT17dGhpcy5oYW5kbGVUb3VjaFRhcERheX1cbiAgICAgICAgICAgICAgICAgIHJlZj1cImNhbGVuZGFyXCJcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGVkRGF0ZT17dGhpcy5zdGF0ZS5zZWxlY3RlZERhdGV9XG4gICAgICAgICAgICAgICAgICBzaG91bGREaXNhYmxlRGF0ZT17dGhpcy5wcm9wcy5zaG91bGREaXNhYmxlRGF0ZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L1NsaWRlSW5UcmFuc2l0aW9uR3JvdXA+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICB9XG4gICAgICAgICAgeyF0aGlzLnN0YXRlLmRpc3BsYXlNb250aERheSAmJlxuICAgICAgICAgICAgPGRpdiBzdHlsZT17cHJlcGFyZVN0eWxlcyhzdHlsZXMueWVhckNvbnRhaW5lcil9PlxuICAgICAgICAgICAgICB7dGhpcy55ZWFyU2VsZWN0b3IoKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIH1cbiAgICAgICAgICB7LypcbiAgICAgICAgICB7b2tMYWJlbCAmJlxuICAgICAgICAgICAgPENhbGVuZGFyQWN0aW9uQnV0dG9uc1xuICAgICAgICAgICAgICBhdXRvT2s9e3RoaXMucHJvcHMuYXV0b09rfVxuICAgICAgICAgICAgICBjYW5jZWxMYWJlbD17Y2FuY2VsTGFiZWx9XG4gICAgICAgICAgICAgIG9rTGFiZWw9e29rTGFiZWx9XG4gICAgICAgICAgICAgIG9uVG91Y2hUYXBDYW5jZWw9e29uVG91Y2hUYXBDYW5jZWx9XG4gICAgICAgICAgICAgIG9uVG91Y2hUYXBPaz17b25Ub3VjaFRhcE9rfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICB9XG4gICAgICAgICAgICAqL31cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbGVuZGFyO1xuIl19