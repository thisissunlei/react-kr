'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _simpleAssign = require('simple-assign');

var _simpleAssign2 = _interopRequireDefault(_simpleAssign);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _dateUtils = require('./dateUtils');

var _DatePickerDialog = require('./DatePickerDialog');

var _DatePickerDialog2 = _interopRequireDefault(_DatePickerDialog);

var _TextField = require('../TextField');

var _TextField2 = _interopRequireDefault(_TextField);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DatePicker = function (_Component) {
  _inherits(DatePicker, _Component);

  function DatePicker() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, DatePicker);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = DatePicker.__proto__ || Object.getPrototypeOf(DatePicker)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      date: undefined
    }, _this.handleAccept = function (date) {
      if (!_this.isControlled()) {
        _this.setState({
          date: date
        });
      }
      if (_this.props.onChange) {
        _this.props.onChange(null, date);
      }
    }, _this.handleFocus = function (event) {
      event.target.blur();
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
    }, _this.handleTouchTap = function (event) {
      if (_this.props.onTouchTap) {
        _this.props.onTouchTap(event);
      }

      if (!_this.props.disabled) {
        setTimeout(function () {
          _this.openDialog();
        }, 0);
      }
    }, _this.formatDate = function (date) {
      if (_this.props.locale) {
        var DateTimeFormat = _this.props.DateTimeFormat || _dateUtils.dateTimeFormat;
        return new DateTimeFormat(_this.props.locale, {
          day: 'numeric',
          month: 'numeric',
          year: 'numeric'
        }).format(date);
      } else {
        return (0, _dateUtils.formatIso)(date);
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(DatePicker, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.setState({
        date: this.isControlled() ? this.getControlledDate() : this.props.defaultDate
      });
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.isControlled()) {
        var newDate = this.getControlledDate(nextProps);
        if (!(0, _dateUtils.isEqualDate)(this.state.date, newDate)) {
          this.setState({
            date: newDate
          });
        }
      }
    }
  }, {
    key: 'getDate',
    value: function getDate() {
      return this.state.date;
    }

    /**
     * Open the date-picker dialog programmatically from a parent.
     */

  }, {
    key: 'openDialog',
    value: function openDialog() {
      /**
       * if the date is not selected then set it to new date
       * (get the current system date while doing so)
       * else set it to the currently selected date
       */
      if (this.state.date !== undefined) {
        this.setState({
          dialogDate: this.getDate()
        }, this.refs.dialogWindow.show);
      } else {
        this.setState({
          dialogDate: new Date()
        }, this.refs.dialogWindow.show);
      }
    }

    /**
     * Alias for `openDialog()` for an api consistent with TextField.
     */

  }, {
    key: 'focus',
    value: function focus() {
      this.openDialog();
    }
  }, {
    key: 'isControlled',
    value: function isControlled() {
      return this.props.hasOwnProperty('value');
    }
  }, {
    key: 'getControlledDate',
    value: function getControlledDate() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;

      if (props.value instanceof Date) {
        return props.value;
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          DateTimeFormat = _props.DateTimeFormat,
          autoOk = _props.autoOk,
          cancelLabel = _props.cancelLabel,
          className = _props.className,
          container = _props.container,
          defaultDate = _props.defaultDate,
          dialogContainerStyle = _props.dialogContainerStyle,
          disableYearSelection = _props.disableYearSelection,
          firstDayOfWeek = _props.firstDayOfWeek,
          formatDateProp = _props.formatDate,
          locale = _props.locale,
          maxDate = _props.maxDate,
          minDate = _props.minDate,
          mode = _props.mode,
          okLabel = _props.okLabel,
          onDismiss = _props.onDismiss,
          onFocus = _props.onFocus,
          onShow = _props.onShow,
          onTouchTap = _props.onTouchTap,
          shouldDisableDate = _props.shouldDisableDate,
          style = _props.style,
          textFieldStyle = _props.textFieldStyle,
          other = _objectWithoutProperties(_props, ['DateTimeFormat', 'autoOk', 'cancelLabel', 'className', 'container', 'defaultDate', 'dialogContainerStyle', 'disableYearSelection', 'firstDayOfWeek', 'formatDate', 'locale', 'maxDate', 'minDate', 'mode', 'okLabel', 'onDismiss', 'onFocus', 'onShow', 'onTouchTap', 'shouldDisableDate', 'style', 'textFieldStyle']);

      var prepareStyles = this.context.muiTheme.prepareStyles;

      var formatDate = formatDateProp || this.formatDate;

      return _react2.default.createElement(
        'div',
        { className: className, style: prepareStyles((0, _simpleAssign2.default)({}, style)) },
        _react2.default.createElement(_TextField2.default, _extends({}, other, {
          onFocus: this.handleFocus,
          onTouchTap: this.handleTouchTap,
          ref: 'input',
          style: textFieldStyle,
          value: this.state.date ? formatDate(this.state.date) : ''
        })),
        _react2.default.createElement(_DatePickerDialog2.default, {
          DateTimeFormat: DateTimeFormat,
          autoOk: autoOk,
          cancelLabel: cancelLabel,
          container: container,
          containerStyle: dialogContainerStyle,
          disableYearSelection: disableYearSelection,
          firstDayOfWeek: firstDayOfWeek,
          initialDate: this.state.dialogDate,
          locale: locale,
          maxDate: maxDate,
          minDate: minDate,
          mode: mode,
          okLabel: okLabel,
          onAccept: this.handleAccept,
          onShow: onShow,
          onDismiss: onDismiss,
          ref: 'dialogWindow',
          shouldDisableDate: shouldDisableDate
        })
      );
    }
  }]);

  return DatePicker;
}(_react.Component);

DatePicker.propTypes = {
  /**
   * Constructor for date formatting for the specified `locale`.
   * The constructor must follow this specification: ECMAScript Internationalization API 1.0 (ECMA-402).
   * `Intl.DateTimeFormat` is supported by most modern browsers, see http://caniuse.com/#search=intl,
   * otherwise https://github.com/andyearnshaw/Intl.js is a good polyfill.
   *
   * By default, a built-in `DateTimeFormat` is used which supports the 'en-US' `locale`.
   */
  DateTimeFormat: _react.PropTypes.func,
  /**
   * If true, automatically accept and close the picker on select a date.
   */
  autoOk: _react.PropTypes.bool,
  /**
   * Override the default text of the 'Cancel' button.
   */
  cancelLabel: _react.PropTypes.node,
  /**
   * The css class name of the root element.
   */
  className: _react.PropTypes.string,
  /**
   * Used to control how the Date Picker will be displayed when the input field is focused.
   * `dialog` (default) displays the DatePicker as a dialog with a modal.
   * `inline` displays the DatePicker below the input field (similar to auto complete).
   */
  container: _react.PropTypes.oneOf(['dialog', 'inline']),
  /**
   * This is the initial date value of the component.
   * If either `value` or `valueLink` is provided they will override this
   * prop with `value` taking precedence.
   */
  defaultDate: _react.PropTypes.object,
  /**
   * Override the inline-styles of DatePickerDialog's Container element.
   */
  dialogContainerStyle: _react.PropTypes.object,
  /**
   * Disables the year selection in the date picker.
   */
  disableYearSelection: _react.PropTypes.bool,
  /**
   * Disables the DatePicker.
   */
  disabled: _react.PropTypes.bool,
  /**
   * Used to change the first day of week. It varies from
   * Saturday to Monday between different locales.
   * The allowed range is 0 (Sunday) to 6 (Saturday).
   * The default is `1`, Monday, as per ISO 8601.
   */
  firstDayOfWeek: _react.PropTypes.number,
  /**
   * This function is called to format the date displayed in the input field, and should return a string.
   * By default if no `locale` and `DateTimeFormat` is provided date objects are formatted to ISO 8601 YYYY-MM-DD.
   *
   * @param {object} date Date object to be formatted.
   * @returns {any} The formatted date.
   */
  formatDate: _react.PropTypes.func,
  /**
   * Locale used for formatting the `DatePicker` date strings. Other than for 'en-US', you
   * must provide a `DateTimeFormat` that supports the chosen `locale`.
   */
  locale: _react.PropTypes.string,
  /**
   * The ending of a range of valid dates. The range includes the endDate.
   * The default value is current date + 100 years.
   */
  maxDate: _react.PropTypes.object,
  /**
   * The beginning of a range of valid dates. The range includes the startDate.
   * The default value is current date - 100 years.
   */
  minDate: _react.PropTypes.object,
  /**
   * Tells the component to display the picker in portrait or landscape mode.
   */
  mode: _react.PropTypes.oneOf(['portrait', 'landscape']),
  /**
   * Override the default text of the 'OK' button.
   */
  okLabel: _react.PropTypes.node,
  /**
   * Callback function that is fired when the date value changes.
   *
   * @param {null} null Since there is no particular event associated with the change,
   * the first argument will always be null.
   * @param {object} date The new date.
   */
  onChange: _react.PropTypes.func,
  /**
   * Callback function that is fired when the Date Picker's dialog is dismissed.
   */
  onDismiss: _react.PropTypes.func,
  /**
   * Callback function that is fired when the Date Picker's `TextField` gains focus.
   */
  onFocus: _react.PropTypes.func,
  /**
   * Callback function that is fired when the Date Picker's dialog is shown.
   */
  onShow: _react.PropTypes.func,
  /**
   * Callback function that is fired when a touch tap event occurs on the Date Picker's `TextField`.
   *
   * @param {object} event TouchTap event targeting the `TextField`.
   */
  onTouchTap: _react.PropTypes.func,
  /**
   * Callback function used to determine if a day's entry should be disabled on the calendar.
   *
   * @param {object} day Date object of a day.
   * @returns {boolean} Indicates whether the day should be disabled.
   */
  shouldDisableDate: _react.PropTypes.func,
  /**
   * Override the inline-styles of the root element.
   */
  style: _react.PropTypes.object,
  /**
   * Override the inline-styles of DatePicker's TextField element.
   */
  textFieldStyle: _react.PropTypes.object,
  /**
   * Sets the date for the Date Picker programmatically.
   */
  value: _react.PropTypes.object
};
DatePicker.defaultProps = {
  autoOk: false,
  container: 'dialog',
  disabled: false,
  disableYearSelection: false,
  firstDayOfWeek: 1,
  style: {}
};
DatePicker.contextTypes = {
  muiTheme: _react.PropTypes.object.isRequired
};
var _default = DatePicker;
exports.default = _default;
;

var _temp2 = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(DatePicker, 'DatePicker', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/DatePicker/DatePicker.js');

  __REACT_HOT_LOADER__.register(_default, 'default', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/DatePicker/DatePicker.js');
}();

;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9Db21wb25lbnRzL0RhdGVQaWNrZXIvRGF0ZVBpY2tlci9EYXRlUGlja2VyLmpzIl0sIm5hbWVzIjpbIkRhdGVQaWNrZXIiLCJzdGF0ZSIsImRhdGUiLCJ1bmRlZmluZWQiLCJoYW5kbGVBY2NlcHQiLCJpc0NvbnRyb2xsZWQiLCJzZXRTdGF0ZSIsInByb3BzIiwib25DaGFuZ2UiLCJoYW5kbGVGb2N1cyIsImV2ZW50IiwidGFyZ2V0IiwiYmx1ciIsIm9uRm9jdXMiLCJoYW5kbGVUb3VjaFRhcCIsIm9uVG91Y2hUYXAiLCJkaXNhYmxlZCIsInNldFRpbWVvdXQiLCJvcGVuRGlhbG9nIiwiZm9ybWF0RGF0ZSIsImxvY2FsZSIsIkRhdGVUaW1lRm9ybWF0IiwiZGF5IiwibW9udGgiLCJ5ZWFyIiwiZm9ybWF0IiwiZ2V0Q29udHJvbGxlZERhdGUiLCJkZWZhdWx0RGF0ZSIsIm5leHRQcm9wcyIsIm5ld0RhdGUiLCJkaWFsb2dEYXRlIiwiZ2V0RGF0ZSIsInJlZnMiLCJkaWFsb2dXaW5kb3ciLCJzaG93IiwiRGF0ZSIsImhhc093blByb3BlcnR5IiwidmFsdWUiLCJhdXRvT2siLCJjYW5jZWxMYWJlbCIsImNsYXNzTmFtZSIsImNvbnRhaW5lciIsImRpYWxvZ0NvbnRhaW5lclN0eWxlIiwiZGlzYWJsZVllYXJTZWxlY3Rpb24iLCJmaXJzdERheU9mV2VlayIsImZvcm1hdERhdGVQcm9wIiwibWF4RGF0ZSIsIm1pbkRhdGUiLCJtb2RlIiwib2tMYWJlbCIsIm9uRGlzbWlzcyIsIm9uU2hvdyIsInNob3VsZERpc2FibGVEYXRlIiwic3R5bGUiLCJ0ZXh0RmllbGRTdHlsZSIsIm90aGVyIiwicHJlcGFyZVN0eWxlcyIsImNvbnRleHQiLCJtdWlUaGVtZSIsInByb3BUeXBlcyIsImZ1bmMiLCJib29sIiwibm9kZSIsInN0cmluZyIsIm9uZU9mIiwib2JqZWN0IiwibnVtYmVyIiwiZGVmYXVsdFByb3BzIiwiY29udGV4dFR5cGVzIiwiaXNSZXF1aXJlZCJdLCJt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S0FKRjtBQUtwQkMsa0JBQWdCLENBTEk7QUFNcEJTLFNBQU87QUFOYSxDO0FBcElsQnJELFUsQ0E2SUdvRSxZLEdBQWU7QUFDcEJWLFlBQVUsaUJBQVVPLE1BQVYsQ0FBaUJJO0FBRFAsQztlQThLVHJFLFU7Ozs7Ozs7OztnQ0EzVFRBLFUiLCJmaWxlIjoiRGF0ZVBpY2tlci5qcyIsInNvdXJjZVJvb3QiOiIvVXNlcnMvdG1hY196Yy9Db2RlL2tyLWFkbWluIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7Q29tcG9uZW50LCBQcm9wVHlwZXN9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7ZGF0ZVRpbWVGb3JtYXQsIGZvcm1hdElzbywgaXNFcXVhbERhdGV9IGZyb20gJy4vZGF0ZVV0aWxzJztcbmltcG9ydCBEYXRlUGlja2VyRGlhbG9nIGZyb20gJy4vRGF0ZVBpY2tlckRpYWxvZyc7XG5pbXBvcnQgVGV4dEZpZWxkIGZyb20gJy4uL1RleHRGaWVsZCc7XG5cbmNsYXNzIERhdGVQaWNrZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBkYXRlIGZvcm1hdHRpbmcgZm9yIHRoZSBzcGVjaWZpZWQgYGxvY2FsZWAuXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIG11c3QgZm9sbG93IHRoaXMgc3BlY2lmaWNhdGlvbjogRUNNQVNjcmlwdCBJbnRlcm5hdGlvbmFsaXphdGlvbiBBUEkgMS4wIChFQ01BLTQwMikuXG4gICAgICogYEludGwuRGF0ZVRpbWVGb3JtYXRgIGlzIHN1cHBvcnRlZCBieSBtb3N0IG1vZGVybiBicm93c2Vycywgc2VlIGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPWludGwsXG4gICAgICogb3RoZXJ3aXNlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmR5ZWFybnNoYXcvSW50bC5qcyBpcyBhIGdvb2QgcG9seWZpbGwuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBhIGJ1aWx0LWluIGBEYXRlVGltZUZvcm1hdGAgaXMgdXNlZCB3aGljaCBzdXBwb3J0cyB0aGUgJ2VuLVVTJyBgbG9jYWxlYC5cbiAgICAgKi9cbiAgICBEYXRlVGltZUZvcm1hdDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgYXV0b21hdGljYWxseSBhY2NlcHQgYW5kIGNsb3NlIHRoZSBwaWNrZXIgb24gc2VsZWN0IGEgZGF0ZS5cbiAgICAgKi9cbiAgICBhdXRvT2s6IFByb3BUeXBlcy5ib29sLFxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHRleHQgb2YgdGhlICdDYW5jZWwnIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBjYW5jZWxMYWJlbDogUHJvcFR5cGVzLm5vZGUsXG4gICAgLyoqXG4gICAgICogVGhlIGNzcyBjbGFzcyBuYW1lIG9mIHRoZSByb290IGVsZW1lbnQuXG4gICAgICovXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gY29udHJvbCBob3cgdGhlIERhdGUgUGlja2VyIHdpbGwgYmUgZGlzcGxheWVkIHdoZW4gdGhlIGlucHV0IGZpZWxkIGlzIGZvY3VzZWQuXG4gICAgICogYGRpYWxvZ2AgKGRlZmF1bHQpIGRpc3BsYXlzIHRoZSBEYXRlUGlja2VyIGFzIGEgZGlhbG9nIHdpdGggYSBtb2RhbC5cbiAgICAgKiBgaW5saW5lYCBkaXNwbGF5cyB0aGUgRGF0ZVBpY2tlciBiZWxvdyB0aGUgaW5wdXQgZmllbGQgKHNpbWlsYXIgdG8gYXV0byBjb21wbGV0ZSkuXG4gICAgICovXG4gICAgY29udGFpbmVyOiBQcm9wVHlwZXMub25lT2YoWydkaWFsb2cnLCAnaW5saW5lJ10pLFxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGluaXRpYWwgZGF0ZSB2YWx1ZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqIElmIGVpdGhlciBgdmFsdWVgIG9yIGB2YWx1ZUxpbmtgIGlzIHByb3ZpZGVkIHRoZXkgd2lsbCBvdmVycmlkZSB0aGlzXG4gICAgICogcHJvcCB3aXRoIGB2YWx1ZWAgdGFraW5nIHByZWNlZGVuY2UuXG4gICAgICovXG4gICAgZGVmYXVsdERhdGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhlIGlubGluZS1zdHlsZXMgb2YgRGF0ZVBpY2tlckRpYWxvZydzIENvbnRhaW5lciBlbGVtZW50LlxuICAgICAqL1xuICAgIGRpYWxvZ0NvbnRhaW5lclN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIHRoZSB5ZWFyIHNlbGVjdGlvbiBpbiB0aGUgZGF0ZSBwaWNrZXIuXG4gICAgICovXG4gICAgZGlzYWJsZVllYXJTZWxlY3Rpb246IFByb3BUeXBlcy5ib29sLFxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIHRoZSBEYXRlUGlja2VyLlxuICAgICAqL1xuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGNoYW5nZSB0aGUgZmlyc3QgZGF5IG9mIHdlZWsuIEl0IHZhcmllcyBmcm9tXG4gICAgICogU2F0dXJkYXkgdG8gTW9uZGF5IGJldHdlZW4gZGlmZmVyZW50IGxvY2FsZXMuXG4gICAgICogVGhlIGFsbG93ZWQgcmFuZ2UgaXMgMCAoU3VuZGF5KSB0byA2IChTYXR1cmRheSkuXG4gICAgICogVGhlIGRlZmF1bHQgaXMgYDFgLCBNb25kYXksIGFzIHBlciBJU08gODYwMS5cbiAgICAgKi9cbiAgICBmaXJzdERheU9mV2VlazogUHJvcFR5cGVzLm51bWJlcixcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB0byBmb3JtYXQgdGhlIGRhdGUgZGlzcGxheWVkIGluIHRoZSBpbnB1dCBmaWVsZCwgYW5kIHNob3VsZCByZXR1cm4gYSBzdHJpbmcuXG4gICAgICogQnkgZGVmYXVsdCBpZiBubyBgbG9jYWxlYCBhbmQgYERhdGVUaW1lRm9ybWF0YCBpcyBwcm92aWRlZCBkYXRlIG9iamVjdHMgYXJlIGZvcm1hdHRlZCB0byBJU08gODYwMSBZWVlZLU1NLURELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGUgRGF0ZSBvYmplY3QgdG8gYmUgZm9ybWF0dGVkLlxuICAgICAqIEByZXR1cm5zIHthbnl9IFRoZSBmb3JtYXR0ZWQgZGF0ZS5cbiAgICAgKi9cbiAgICBmb3JtYXREYXRlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAvKipcbiAgICAgKiBMb2NhbGUgdXNlZCBmb3IgZm9ybWF0dGluZyB0aGUgYERhdGVQaWNrZXJgIGRhdGUgc3RyaW5ncy4gT3RoZXIgdGhhbiBmb3IgJ2VuLVVTJywgeW91XG4gICAgICogbXVzdCBwcm92aWRlIGEgYERhdGVUaW1lRm9ybWF0YCB0aGF0IHN1cHBvcnRzIHRoZSBjaG9zZW4gYGxvY2FsZWAuXG4gICAgICovXG4gICAgbG9jYWxlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIC8qKlxuICAgICAqIFRoZSBlbmRpbmcgb2YgYSByYW5nZSBvZiB2YWxpZCBkYXRlcy4gVGhlIHJhbmdlIGluY2x1ZGVzIHRoZSBlbmREYXRlLlxuICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGN1cnJlbnQgZGF0ZSArIDEwMCB5ZWFycy5cbiAgICAgKi9cbiAgICBtYXhEYXRlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIC8qKlxuICAgICAqIFRoZSBiZWdpbm5pbmcgb2YgYSByYW5nZSBvZiB2YWxpZCBkYXRlcy4gVGhlIHJhbmdlIGluY2x1ZGVzIHRoZSBzdGFydERhdGUuXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgY3VycmVudCBkYXRlIC0gMTAwIHllYXJzLlxuICAgICAqL1xuICAgIG1pbkRhdGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIGNvbXBvbmVudCB0byBkaXNwbGF5IHRoZSBwaWNrZXIgaW4gcG9ydHJhaXQgb3IgbGFuZHNjYXBlIG1vZGUuXG4gICAgICovXG4gICAgbW9kZTogUHJvcFR5cGVzLm9uZU9mKFsncG9ydHJhaXQnLCAnbGFuZHNjYXBlJ10pLFxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHRleHQgb2YgdGhlICdPSycgYnV0dG9uLlxuICAgICAqL1xuICAgIG9rTGFiZWw6IFByb3BUeXBlcy5ub2RlLFxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgZmlyZWQgd2hlbiB0aGUgZGF0ZSB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudWxsfSBudWxsIFNpbmNlIHRoZXJlIGlzIG5vIHBhcnRpY3VsYXIgZXZlbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGFuZ2UsXG4gICAgICogdGhlIGZpcnN0IGFyZ3VtZW50IHdpbGwgYWx3YXlzIGJlIG51bGwuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGUgVGhlIG5ldyBkYXRlLlxuICAgICAqL1xuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGZpcmVkIHdoZW4gdGhlIERhdGUgUGlja2VyJ3MgZGlhbG9nIGlzIGRpc21pc3NlZC5cbiAgICAgKi9cbiAgICBvbkRpc21pc3M6IFByb3BUeXBlcy5mdW5jLFxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgZmlyZWQgd2hlbiB0aGUgRGF0ZSBQaWNrZXIncyBgVGV4dEZpZWxkYCBnYWlucyBmb2N1cy5cbiAgICAgKi9cbiAgICBvbkZvY3VzOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGZpcmVkIHdoZW4gdGhlIERhdGUgUGlja2VyJ3MgZGlhbG9nIGlzIHNob3duLlxuICAgICAqL1xuICAgIG9uU2hvdzogUHJvcFR5cGVzLmZ1bmMsXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBmaXJlZCB3aGVuIGEgdG91Y2ggdGFwIGV2ZW50IG9jY3VycyBvbiB0aGUgRGF0ZSBQaWNrZXIncyBgVGV4dEZpZWxkYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUb3VjaFRhcCBldmVudCB0YXJnZXRpbmcgdGhlIGBUZXh0RmllbGRgLlxuICAgICAqL1xuICAgIG9uVG91Y2hUYXA6IFByb3BUeXBlcy5mdW5jLFxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGEgZGF5J3MgZW50cnkgc2hvdWxkIGJlIGRpc2FibGVkIG9uIHRoZSBjYWxlbmRhci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXkgRGF0ZSBvYmplY3Qgb2YgYSBkYXkuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IEluZGljYXRlcyB3aGV0aGVyIHRoZSBkYXkgc2hvdWxkIGJlIGRpc2FibGVkLlxuICAgICAqL1xuICAgIHNob3VsZERpc2FibGVEYXRlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGUgaW5saW5lLXN0eWxlcyBvZiB0aGUgcm9vdCBlbGVtZW50LlxuICAgICAqL1xuICAgIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoZSBpbmxpbmUtc3R5bGVzIG9mIERhdGVQaWNrZXIncyBUZXh0RmllbGQgZWxlbWVudC5cbiAgICAgKi9cbiAgICB0ZXh0RmllbGRTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkYXRlIGZvciB0aGUgRGF0ZSBQaWNrZXIgcHJvZ3JhbW1hdGljYWxseS5cbiAgICAgKi9cbiAgICB2YWx1ZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGF1dG9PazogZmFsc2UsXG4gICAgY29udGFpbmVyOiAnZGlhbG9nJyxcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgZGlzYWJsZVllYXJTZWxlY3Rpb246IGZhbHNlLFxuICAgIGZpcnN0RGF5T2ZXZWVrOiAxLFxuICAgIHN0eWxlOiB7fSxcbiAgfTtcblxuICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgIG11aVRoZW1lOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIH07XG5cbiAgc3RhdGUgPSB7XG4gICAgZGF0ZTogdW5kZWZpbmVkLFxuICB9O1xuXG4gIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGRhdGU6IHRoaXMuaXNDb250cm9sbGVkKCkgPyB0aGlzLmdldENvbnRyb2xsZWREYXRlKCkgOiB0aGlzLnByb3BzLmRlZmF1bHREYXRlLFxuICAgIH0pO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAodGhpcy5pc0NvbnRyb2xsZWQoKSkge1xuICAgICAgY29uc3QgbmV3RGF0ZSA9IHRoaXMuZ2V0Q29udHJvbGxlZERhdGUobmV4dFByb3BzKTtcbiAgICAgIGlmICghaXNFcXVhbERhdGUodGhpcy5zdGF0ZS5kYXRlLCBuZXdEYXRlKSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBkYXRlOiBuZXdEYXRlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXREYXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmRhdGU7XG4gIH1cblxuICAvKipcbiAgICogT3BlbiB0aGUgZGF0ZS1waWNrZXIgZGlhbG9nIHByb2dyYW1tYXRpY2FsbHkgZnJvbSBhIHBhcmVudC5cbiAgICovXG4gIG9wZW5EaWFsb2coKSB7XG4gICAgLyoqXG4gICAgICogaWYgdGhlIGRhdGUgaXMgbm90IHNlbGVjdGVkIHRoZW4gc2V0IGl0IHRvIG5ldyBkYXRlXG4gICAgICogKGdldCB0aGUgY3VycmVudCBzeXN0ZW0gZGF0ZSB3aGlsZSBkb2luZyBzbylcbiAgICAgKiBlbHNlIHNldCBpdCB0byB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGVcbiAgICAgKi9cbiAgICBpZiAodGhpcy5zdGF0ZS5kYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBkaWFsb2dEYXRlOiB0aGlzLmdldERhdGUoKSxcbiAgICAgIH0sIHRoaXMucmVmcy5kaWFsb2dXaW5kb3cuc2hvdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBkaWFsb2dEYXRlOiBuZXcgRGF0ZSgpLFxuICAgICAgfSwgdGhpcy5yZWZzLmRpYWxvZ1dpbmRvdy5zaG93KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWxpYXMgZm9yIGBvcGVuRGlhbG9nKClgIGZvciBhbiBhcGkgY29uc2lzdGVudCB3aXRoIFRleHRGaWVsZC5cbiAgICovXG4gIGZvY3VzKCkge1xuICAgIHRoaXMub3BlbkRpYWxvZygpO1xuICB9XG5cbiAgaGFuZGxlQWNjZXB0ID0gKGRhdGUpID0+IHtcbiAgICBpZiAoIXRoaXMuaXNDb250cm9sbGVkKCkpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBkYXRlOiBkYXRlLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BzLm9uQ2hhbmdlKSB7XG4gICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKG51bGwsIGRhdGUpO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVGb2N1cyA9IChldmVudCkgPT4ge1xuICAgIGV2ZW50LnRhcmdldC5ibHVyKCk7XG4gICAgaWYgKHRoaXMucHJvcHMub25Gb2N1cykge1xuICAgICAgdGhpcy5wcm9wcy5vbkZvY3VzKGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlVG91Y2hUYXAgPSAoZXZlbnQpID0+IHtcbiAgICBpZiAodGhpcy5wcm9wcy5vblRvdWNoVGFwKSB7XG4gICAgICB0aGlzLnByb3BzLm9uVG91Y2hUYXAoZXZlbnQpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMub3BlbkRpYWxvZygpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9O1xuXG4gIGlzQ29udHJvbGxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKTtcbiAgfVxuXG4gIGdldENvbnRyb2xsZWREYXRlKHByb3BzID0gdGhpcy5wcm9wcykge1xuICAgIGlmIChwcm9wcy52YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiBwcm9wcy52YWx1ZTtcbiAgICB9XG4gIH1cblxuICBmb3JtYXREYXRlID0gKGRhdGUpID0+IHtcbiAgICBpZiAodGhpcy5wcm9wcy5sb2NhbGUpIHtcbiAgICAgIGNvbnN0IERhdGVUaW1lRm9ybWF0ID0gdGhpcy5wcm9wcy5EYXRlVGltZUZvcm1hdCB8fCBkYXRlVGltZUZvcm1hdDtcbiAgICAgIHJldHVybiBuZXcgRGF0ZVRpbWVGb3JtYXQodGhpcy5wcm9wcy5sb2NhbGUsIHtcbiAgICAgICAgZGF5OiAnbnVtZXJpYycsXG4gICAgICAgIG1vbnRoOiAnbnVtZXJpYycsXG4gICAgICAgIHllYXI6ICdudW1lcmljJyxcbiAgICAgIH0pLmZvcm1hdChkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZvcm1hdElzbyhkYXRlKTtcbiAgICB9XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIERhdGVUaW1lRm9ybWF0LFxuICAgICAgYXV0b09rLFxuICAgICAgY2FuY2VsTGFiZWwsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICBjb250YWluZXIsXG4gICAgICBkZWZhdWx0RGF0ZSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgZGlhbG9nQ29udGFpbmVyU3R5bGUsXG4gICAgICBkaXNhYmxlWWVhclNlbGVjdGlvbixcbiAgICAgIGZpcnN0RGF5T2ZXZWVrLFxuICAgICAgZm9ybWF0RGF0ZTogZm9ybWF0RGF0ZVByb3AsXG4gICAgICBsb2NhbGUsXG4gICAgICBtYXhEYXRlLFxuICAgICAgbWluRGF0ZSxcbiAgICAgIG1vZGUsXG4gICAgICBva0xhYmVsLFxuICAgICAgb25EaXNtaXNzLFxuICAgICAgb25Gb2N1cywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgb25TaG93LFxuICAgICAgb25Ub3VjaFRhcCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgc2hvdWxkRGlzYWJsZURhdGUsXG4gICAgICBzdHlsZSxcbiAgICAgIHRleHRGaWVsZFN0eWxlLFxuICAgICAgLi4ub3RoZXJcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IHtwcmVwYXJlU3R5bGVzfSA9IHRoaXMuY29udGV4dC5tdWlUaGVtZTtcbiAgICBjb25zdCBmb3JtYXREYXRlID0gZm9ybWF0RGF0ZVByb3AgfHwgdGhpcy5mb3JtYXREYXRlO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWV9IHN0eWxlPXtwcmVwYXJlU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIHN0eWxlKSl9PlxuICAgICAgICA8VGV4dEZpZWxkXG4gICAgICAgICAgey4uLm90aGVyfVxuICAgICAgICAgIG9uRm9jdXM9e3RoaXMuaGFuZGxlRm9jdXN9XG4gICAgICAgICAgb25Ub3VjaFRhcD17dGhpcy5oYW5kbGVUb3VjaFRhcH1cbiAgICAgICAgICByZWY9XCJpbnB1dFwiXG4gICAgICAgICAgc3R5bGU9e3RleHRGaWVsZFN0eWxlfVxuICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLmRhdGUgPyBmb3JtYXREYXRlKHRoaXMuc3RhdGUuZGF0ZSkgOiAnJ31cbiAgICAgICAgLz5cbiAgICAgICAgPERhdGVQaWNrZXJEaWFsb2dcbiAgICAgICAgICBEYXRlVGltZUZvcm1hdD17RGF0ZVRpbWVGb3JtYXR9XG4gICAgICAgICAgYXV0b09rPXthdXRvT2t9XG4gICAgICAgICAgY2FuY2VsTGFiZWw9e2NhbmNlbExhYmVsfVxuICAgICAgICAgIGNvbnRhaW5lcj17Y29udGFpbmVyfVxuICAgICAgICAgIGNvbnRhaW5lclN0eWxlPXtkaWFsb2dDb250YWluZXJTdHlsZX1cbiAgICAgICAgICBkaXNhYmxlWWVhclNlbGVjdGlvbj17ZGlzYWJsZVllYXJTZWxlY3Rpb259XG4gICAgICAgICAgZmlyc3REYXlPZldlZWs9e2ZpcnN0RGF5T2ZXZWVrfVxuICAgICAgICAgIGluaXRpYWxEYXRlPXt0aGlzLnN0YXRlLmRpYWxvZ0RhdGV9XG4gICAgICAgICAgbG9jYWxlPXtsb2NhbGV9XG4gICAgICAgICAgbWF4RGF0ZT17bWF4RGF0ZX1cbiAgICAgICAgICBtaW5EYXRlPXttaW5EYXRlfVxuICAgICAgICAgIG1vZGU9e21vZGV9XG4gICAgICAgICAgb2tMYWJlbD17b2tMYWJlbH1cbiAgICAgICAgICBvbkFjY2VwdD17dGhpcy5oYW5kbGVBY2NlcHR9XG4gICAgICAgICAgb25TaG93PXtvblNob3d9XG4gICAgICAgICAgb25EaXNtaXNzPXtvbkRpc21pc3N9XG4gICAgICAgICAgcmVmPVwiZGlhbG9nV2luZG93XCJcbiAgICAgICAgICBzaG91bGREaXNhYmxlRGF0ZT17c2hvdWxkRGlzYWJsZURhdGV9XG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERhdGVQaWNrZXI7XG4iXX0=