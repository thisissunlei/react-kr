'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _simpleAssign = require('simple-assign');

var _simpleAssign2 = _interopRequireDefault(_simpleAssign);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _shallowequal = require('shallowequal');

var _shallowequal2 = _interopRequireDefault(_shallowequal);

var _transitions = require('../styles/transitions');

var _transitions2 = _interopRequireDefault(_transitions);

var _EnhancedTextarea = require('./EnhancedTextarea');

var _EnhancedTextarea2 = _interopRequireDefault(_EnhancedTextarea);

var _TextFieldHint = require('./TextFieldHint');

var _TextFieldHint2 = _interopRequireDefault(_TextFieldHint);

var _TextFieldLabel = require('./TextFieldLabel');

var _TextFieldLabel2 = _interopRequireDefault(_TextFieldLabel);

var _TextFieldUnderline = require('./TextFieldUnderline');

var _TextFieldUnderline2 = _interopRequireDefault(_TextFieldUnderline);

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var getStyles = function getStyles(props, context, state) {
  var _context$muiTheme = context.muiTheme,
      baseTheme = _context$muiTheme.baseTheme,
      _context$muiTheme$tex = _context$muiTheme.textField,
      floatingLabelColor = _context$muiTheme$tex.floatingLabelColor,
      focusColor = _context$muiTheme$tex.focusColor,
      textColor = _context$muiTheme$tex.textColor,
      disabledTextColor = _context$muiTheme$tex.disabledTextColor,
      backgroundColor = _context$muiTheme$tex.backgroundColor,
      errorColor = _context$muiTheme$tex.errorColor;


  var styles = {
    root: {
      fontSize: 16,
      lineHeight: '24px',
      width: props.fullWidth ? '100%' : 256,
      height: (props.rows - 1) * 24 + (props.floatingLabelText ? 72 : 48),
      display: 'inline-block',
      position: 'relative',
      backgroundColor: backgroundColor,
      fontFamily: baseTheme.fontFamily,
      transition: _transitions2.default.easeOut('200ms', 'height'),
      cursor: props.disabled ? 'not-allowed' : 'auto'
    },
    error: {
      position: 'relative',
      bottom: 2,
      fontSize: 12,
      lineHeight: '12px',
      color: errorColor,
      transition: _transitions2.default.easeOut()
    },
    floatingLabel: {
      color: props.disabled ? disabledTextColor : floatingLabelColor,
      pointerEvents: 'none'
    },
    input: {
      padding: 0,
      position: 'relative',
      width: '100%',
      border: 'none',
      outline: 'none',
      backgroundColor: 'rgba(0,0,0,0)',
      color: props.disabled ? disabledTextColor : textColor,
      cursor: 'inherit',
      font: 'inherit',
      WebkitTapHighlightColor: 'rgba(0,0,0,0)' },
    inputNative: {
      appearance: 'textfield' }
  };

  styles.textarea = (0, _simpleAssign2.default)({}, styles.input, {
    marginTop: props.floatingLabelText ? 36 : 12,
    marginBottom: props.floatingLabelText ? -36 : -12,
    boxSizing: 'border-box',
    font: 'inherit'
  });

  // Do not assign a height to the textarea as he handles it on his own.
  styles.input.height = '100%';

  if (state.isFocused) {
    styles.floatingLabel.color = focusColor;
  }

  if (props.floatingLabelText) {
    styles.input.boxSizing = 'border-box';

    if (!props.multiLine) {
      styles.input.marginTop = 14;
    }

    if (state.errorText) {
      styles.error.bottom = !props.multiLine ? styles.error.fontSize + 3 : 3;
    }
  }

  if (state.errorText) {
    if (state.isFocused) {
      styles.floatingLabel.color = styles.error.color;
    }
  }

  return styles;
};

/**
 * Check if a value is valid to be displayed inside an input.
 *
 * @param The value to check.
 * @returns True if the string provided is valid, false otherwise.
 */
function isValid(value) {
  return value !== '' && value !== undefined && value !== null;
}

var TextField = function (_Component) {
  _inherits(TextField, _Component);

  function TextField() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, TextField);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = TextField.__proto__ || Object.getPrototypeOf(TextField)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      isFocused: false,
      errorText: undefined,
      hasValue: false
    }, _this.handleInputBlur = function (event) {
      _this.setState({ isFocused: false });
      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }
    }, _this.handleInputChange = function (event) {
      _this.setState({ hasValue: isValid(event.target.value) });
      if (_this.props.onChange) {
        _this.props.onChange(event, event.target.value);
      }
    }, _this.handleInputFocus = function (event) {
      if (_this.props.disabled) {
        return;
      }
      _this.setState({ isFocused: true });
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
    }, _this.handleHeightChange = function (event, height) {
      var newHeight = height + 24;
      if (_this.props.floatingLabelText) {
        newHeight += 24;
      }
      _reactDom2.default.findDOMNode(_this).style.height = newHeight + 'px';
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(TextField, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      var _props = this.props,
          children = _props.children,
          name = _props.name,
          hintText = _props.hintText,
          floatingLabelText = _props.floatingLabelText,
          id = _props.id;


      var propsLeaf = children ? children.props : this.props;

      this.setState({
        errorText: this.props.errorText,
        hasValue: isValid(propsLeaf.value) || isValid(propsLeaf.defaultValue)
      });

      process.env.NODE_ENV !== "production" ? (0, _warning2.default)(name || hintText || floatingLabelText || id, 'Material-UI: We don\'t have enough information\n      to build a robust unique id for the TextField component. Please provide an id or a name.') : void 0;

      var uniqueId = name + '-' + hintText + '-' + floatingLabelText + '-' + Math.floor(Math.random() * 0xFFFF);
      this.uniqueId = uniqueId.replace(/[^A-Za-z0-9-]/gi, '');
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.errorText !== this.props.errorText) {
        this.setState({
          errorText: nextProps.errorText
        });
      }

      if (nextProps.children && nextProps.children.props) {
        nextProps = nextProps.children.props;
      }

      if (nextProps.hasOwnProperty('value')) {
        var hasValue = isValid(nextProps.value);

        this.setState({
          hasValue: hasValue
        });
      }
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState, nextContext) {
      return !(0, _shallowequal2.default)(this.props, nextProps) || !(0, _shallowequal2.default)(this.state, nextState) || !(0, _shallowequal2.default)(this.context, nextContext);
    }
  }, {
    key: 'blur',
    value: function blur() {
      if (this.input) {
        this.getInputNode().blur();
      }
    }
  }, {
    key: 'focus',
    value: function focus() {
      if (this.input) {
        this.getInputNode().focus();
      }
    }
  }, {
    key: 'select',
    value: function select() {
      if (this.input) {
        this.getInputNode().select();
      }
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.input ? this.getInputNode().value : undefined;
    }
  }, {
    key: 'getInputNode',
    value: function getInputNode() {
      return this.props.children || this.props.multiLine ? this.input.getInputNode() : _reactDom2.default.findDOMNode(this.input);
    }
  }, {
    key: '_isControlled',
    value: function _isControlled() {
      return this.props.hasOwnProperty('value');
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props2 = this.props,
          children = _props2.children,
          className = _props2.className,
          disabled = _props2.disabled,
          errorStyle = _props2.errorStyle,
          errorText = _props2.errorText,
          floatingLabelFixed = _props2.floatingLabelFixed,
          floatingLabelFocusStyle = _props2.floatingLabelFocusStyle,
          floatingLabelShrinkStyle = _props2.floatingLabelShrinkStyle,
          floatingLabelStyle = _props2.floatingLabelStyle,
          floatingLabelText = _props2.floatingLabelText,
          fullWidth = _props2.fullWidth,
          hintText = _props2.hintText,
          hintStyle = _props2.hintStyle,
          id = _props2.id,
          inputStyle = _props2.inputStyle,
          multiLine = _props2.multiLine,
          onBlur = _props2.onBlur,
          onChange = _props2.onChange,
          onFocus = _props2.onFocus,
          style = _props2.style,
          type = _props2.type,
          underlineDisabledStyle = _props2.underlineDisabledStyle,
          underlineFocusStyle = _props2.underlineFocusStyle,
          underlineShow = _props2.underlineShow,
          underlineStyle = _props2.underlineStyle,
          rows = _props2.rows,
          rowsMax = _props2.rowsMax,
          textareaStyle = _props2.textareaStyle,
          other = _objectWithoutProperties(_props2, ['children', 'className', 'disabled', 'errorStyle', 'errorText', 'floatingLabelFixed', 'floatingLabelFocusStyle', 'floatingLabelShrinkStyle', 'floatingLabelStyle', 'floatingLabelText', 'fullWidth', 'hintText', 'hintStyle', 'id', 'inputStyle', 'multiLine', 'onBlur', 'onChange', 'onFocus', 'style', 'type', 'underlineDisabledStyle', 'underlineFocusStyle', 'underlineShow', 'underlineStyle', 'rows', 'rowsMax', 'textareaStyle']);

      var prepareStyles = this.context.muiTheme.prepareStyles;

      var styles = getStyles(this.props, this.context, this.state);
      var inputId = id || this.uniqueId;

      var errorTextElement = this.state.errorText && _react2.default.createElement(
        'div',
        { style: prepareStyles((0, _simpleAssign2.default)(styles.error, errorStyle)) },
        this.state.errorText
      );

      var floatingLabelTextElement = floatingLabelText && _react2.default.createElement(
        _TextFieldLabel2.default,
        {
          muiTheme: this.context.muiTheme,
          style: (0, _simpleAssign2.default)(styles.floatingLabel, floatingLabelStyle, this.state.isFocused ? floatingLabelFocusStyle : null),
          shrinkStyle: floatingLabelShrinkStyle,
          htmlFor: inputId,
          shrink: this.state.hasValue || this.state.isFocused || floatingLabelFixed,
          disabled: disabled
        },
        floatingLabelText
      );

      var inputProps = {
        id: inputId,
        ref: function ref(elem) {
          return _this2.input = elem;
        },
        disabled: this.props.disabled,
        onBlur: this.handleInputBlur,
        onChange: this.handleInputChange,
        onFocus: this.handleInputFocus
      };

      var childStyleMerged = (0, _simpleAssign2.default)(styles.input, inputStyle);

      var inputElement = void 0;
      if (children) {
        inputElement = _react2.default.cloneElement(children, _extends({}, inputProps, children.props, {
          style: (0, _simpleAssign2.default)(childStyleMerged, children.props.style)
        }));
      } else {
        inputElement = multiLine ? _react2.default.createElement(_EnhancedTextarea2.default, _extends({
          style: childStyleMerged,
          textareaStyle: (0, _simpleAssign2.default)(styles.textarea, styles.inputNative, textareaStyle),
          rows: rows,
          rowsMax: rowsMax
        }, other, inputProps, {
          onHeightChange: this.handleHeightChange
        })) : _react2.default.createElement('input', _extends({
          type: type,
          style: prepareStyles((0, _simpleAssign2.default)(styles.inputNative, childStyleMerged))
        }, other, inputProps));
      }

      var rootProps = {};

      if (children) {
        rootProps = other;
      }

      return _react2.default.createElement(
        'div',
        _extends({}, rootProps, {
          className: className,
          style: prepareStyles((0, _simpleAssign2.default)(styles.root, style))
        }),
        floatingLabelTextElement,
        hintText ? _react2.default.createElement(_TextFieldHint2.default, {
          muiTheme: this.context.muiTheme,
          show: !(this.state.hasValue || floatingLabelText && !this.state.isFocused) || !this.state.hasValue && floatingLabelText && floatingLabelFixed && !this.state.isFocused,
          style: hintStyle,
          text: hintText
        }) : null,
        inputElement,
        underlineShow ? _react2.default.createElement(_TextFieldUnderline2.default, {
          disabled: disabled,
          disabledStyle: underlineDisabledStyle,
          error: !!this.state.errorText,
          errorStyle: errorStyle,
          focus: this.state.isFocused,
          focusStyle: underlineFocusStyle,
          muiTheme: this.context.muiTheme,
          style: underlineStyle
        }) : null,
        errorTextElement
      );
    }
  }]);

  return TextField;
}(_react.Component);

TextField.propTypes = {
  children: _react.PropTypes.node,
  /**
   * The css class name of the root element.
   */
  className: _react.PropTypes.string,
  /**
   * The text string to use for the default value.
   */
  defaultValue: _react.PropTypes.any,
  /**
   * Disables the text field if set to true.
   */
  disabled: _react.PropTypes.bool,
  /**
   * The style object to use to override error styles.
   */
  errorStyle: _react.PropTypes.object,
  /**
   * The error content to display.
   */
  errorText: _react.PropTypes.node,
  /**
   * If true, the floating label will float even when there is no value.
   */
  floatingLabelFixed: _react.PropTypes.bool,
  /**
   * The style object to use to override floating label styles when focused.
   */
  floatingLabelFocusStyle: _react.PropTypes.object,
  /**
   * The style object to use to override floating label styles when shrunk.
   */
  floatingLabelShrinkStyle: _react.PropTypes.object,
  /**
   * The style object to use to override floating label styles.
   */
  floatingLabelStyle: _react.PropTypes.object,
  /**
   * The content to use for the floating label element.
   */
  floatingLabelText: _react.PropTypes.node,
  /**
   * If true, the field receives the property width 100%.
   */
  fullWidth: _react.PropTypes.bool,
  /**
   * Override the inline-styles of the TextField's hint text element.
   */
  hintStyle: _react.PropTypes.object,
  /**
   * The hint content to display.
   */
  hintText: _react.PropTypes.node,
  /**
   * The id prop for the text field.
   */
  id: _react.PropTypes.string,
  /**
   * Override the inline-styles of the TextField's input element.
   * When multiLine is false: define the style of the input element.
   * When multiLine is true: define the style of the container of the textarea.
   */
  inputStyle: _react.PropTypes.object,
  /**
   * If true, a textarea element will be rendered.
   * The textarea also grows and shrinks according to the number of lines.
   */
  multiLine: _react.PropTypes.bool,
  /**
   * Name applied to the input.
   */
  name: _react.PropTypes.string,
  /** @ignore */
  onBlur: _react.PropTypes.func,
  /**
   * Callback function that is fired when the textfield's value changes.
   */
  onChange: _react.PropTypes.func,
  /** @ignore */
  onFocus: _react.PropTypes.func,
  /**
   * Number of rows to display when multiLine option is set to true.
   */
  rows: _react.PropTypes.number,
  /**
   * Maximum number of rows to display when
   * multiLine option is set to true.
   */
  rowsMax: _react.PropTypes.number,
  /**
   * Override the inline-styles of the root element.
   */
  style: _react.PropTypes.object,
  /**
   * Override the inline-styles of the TextField's textarea element.
   * The TextField use either a textarea or an input,
   * this property has effects only when multiLine is true.
   */
  textareaStyle: _react.PropTypes.object,
  /**
   * Specifies the type of input to display
   * such as "password" or "text".
   */
  type: _react.PropTypes.string,
  /**
   * Override the inline-styles of the
   * TextField's underline element when disabled.
   */
  underlineDisabledStyle: _react.PropTypes.object,
  /**
   * Override the inline-styles of the TextField's
   * underline element when focussed.
   */
  underlineFocusStyle: _react.PropTypes.object,
  /**
   * If true, shows the underline for the text field.
   */
  underlineShow: _react.PropTypes.bool,
  /**
   * Override the inline-styles of the TextField's underline element.
   */
  underlineStyle: _react.PropTypes.object,
  /**
   * The value of the text field.
   */
  value: _react.PropTypes.any
};
TextField.defaultProps = {
  disabled: false,
  floatingLabelFixed: false,
  multiLine: false,
  fullWidth: false,
  type: 'text',
  underlineShow: true,
  rows: 1
};
TextField.contextTypes = {
  muiTheme: _react.PropTypes.object.isRequired
};
var _default = TextField;
exports.default = _default;
;

var _temp2 = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(getStyles, 'getStyles', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/TextField/TextField.js');

  __REACT_HOT_LOADER__.register(isValid, 'isValid', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/TextField/TextField.js');

  __REACT_HOT_LOADER__.register(TextField, 'TextField', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/TextField/TextField.js');

  __REACT_HOT_LOADER__.register(_default, 'default', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/TextField/TextField.js');
}();

;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9Db21wb25lbnRzL0RhdGVQaWNrZXIvVGV4dEZpZWxkL1RleHRGaWVsZC5qcyJdLCJuYW1lcyI6WyJnZXRTdHlsZXMiLCJwcm9wcyIsImNvbnRleHQiLCJzdGF0ZSIsIm11aVRoZW1lIiwiYmFzZVRoZW1lIiwidGV4dEZpZWxkIiwiZmxvYXRpbmdMYWJlbENvbG9yIiwiZm9jdXNDb2xvciIsInRleHRDb2xvciIsImRpc2FibGVkVGV4dENvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwiZXJyb3JDb2xvciIsInN0eWxlcyIsInJvb3QiLCJmb250U2l6ZSIsImxpbmVIZWlnaHQiLCJ3aWR0aCIsImZ1bGxXaWR0aCIsImhlaWdodCIsInJvd3MiLCJmbG9hdGluZ0xhYmVsVGV4dCIsImRpc3BsYXkiLCJwb3NpdGlvbiIsImZvbnRGYW1pbHkiLCJ0cmFuc2l0aW9uIiwiZWFzZU91dCIsImN1cnNvciIsImRpc2FibGVkIiwiZXJyb3IiLCJib3R0b20iLCJjb2xvciIsImZsb2F0aW5nTGFiZWwiLCJwb2ludGVyRXZlbnRzIiwiaW5wdXQiLCJwYWRkaW5nIiwiYm9yZGVyIiwib3V0bGluZSIsImZvbnQiLCJXZWJraXRUYXBIaWdobGlnaHRDb2xvciIsImlucHV0TmF0aXZlIiwiYXBwZWFyYW5jZSIsInRleHRhcmVhIiwibWFyZ2luVG9wIiwibWFyZ2luQm90dG9tIiwiYm94U2l6aW5nIiwiaXNGb2N1c2VkIiwibXVsdGlMaW5lIiwiZXJyb3JUZXh0IiwiaXNWYWxpZCIsInZhbHVlIiwidW5kZWZpbmVkIiwiVGV4dEZpZWxkIiwiaGFzVmFsdWUiLCJoYW5kbGVJbnB1dEJsdXIiLCJldmVudCIsInNldFN0YXRlIiwib25CbHVyIiwiaGFuZGxlSW5wdXRDaGFuZ2UiLCJ0YXJnZXQiLCJvbkNoYW5nZSIsImhhbmRsZUlucHV0Rm9jdXMiLCJvbkZvY3VzIiwiaGFuZGxlSGVpZ2h0Q2hhbmdlIiwibmV3SGVpZ2h0IiwiZmluZERPTU5vZGUiLCJzdHlsZSIsImNoaWxkcmVuIiwibmFtZSIsImhpbnRUZXh0IiwiaWQiLCJwcm9wc0xlYWYiLCJkZWZhdWx0VmFsdWUiLCJ1bmlxdWVJZCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInJlcGxhY2UiLCJuZXh0UHJvcHMiLCJoYXNPd25Qcm9wZXJ0eSIsIm5leHRTdGF0ZSIsIm5leHRDb250ZXh0IiwiZ2V0SW5wdXROb2RlIiwiYmx1ciIsImZvY3VzIiwic2VsZWN0IiwiY2xhc3NOYW1lIiwiZXJyb3JTdHlsZSIsImZsb2F0aW5nTGFiZWxGaXhlZCIsImZsb2F0aW5nTGFiZWxGb2N1c1N0eWxlIiwiZmxvYXRpbmdMYWJlbFNocmlua1N0eWxlIiwiZmxvYXRpbmdMYWJlbFN0eWxlIiwiaGludFN0eWxlIiwiaW5wdXRTdHlsZSIsInR5cGUiLCJ1bmRlcmxpbmVEaXNhYmxlZFN0eWxlIiwidW5kZXJsaW5lRm9jdXNTdHlsZSIsInVuZGVybGluZVNob3ciLCJ1bmRlcmxpbmVTdHlsZSIsInJvd3NNYXgiLCJ0ZXh0YXJlYVN0eWxlIiwib3RoZXIiLCJwcmVwYXJlU3R5bGVzIiwiaW5wdXRJZCIsImVycm9yVGV4dEVsZW1lbnQiLCJmbG9hdGluZ0xhYmVsVGV4dEVsZW1lbnQiLCJpbnB1dFByb3BzIiwicmVmIiwiZWxlbSIsImNoaWxkU3R5bGVNZXJnZWQiLCJpbnB1dEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJyb290UHJvcHMiLCJwcm9wVHlwZXMiLCJub2RlIiwic3RyaW5nIiwiYW55IiwiYm9vbCIsIm9iamVjdCIsImZ1bmMiLCJudW1iZXIiLCJkZWZhdWx0UHJvcHMiLCJjb250ZXh0VHlwZXMiLCJpc1JlcXVpcmVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxZQUFZLFNBQVpBLFNBQVksQ0FBQ0MsS0FBRCxFQUFRQyxPQUFSLEVBQWlCQyxLQUFqQixFQUEy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R0FBZTtBQUNwQjdGLFlBQVUsS0FEVTtBQUVwQjRELHNCQUFvQixLQUZBO0FBR3BCekMsYUFBVyxLQUhTO0FBSXBCN0IsYUFBVyxLQUpTO0FBS3BCNEUsUUFBTSxNQUxjO0FBTXBCRyxpQkFBZSxJQU5LO0FBT3BCN0UsUUFBTTtBQVBjLEM7QUFsSWxCZ0MsUyxDQTRJR3NFLFksR0FBZTtBQUNwQnRILFlBQVUsaUJBQVVrSCxNQUFWLENBQWlCSztBQURQLEM7ZUE0UVR2RSxTOzs7Ozs7Ozs7Z0NBNWZUcEQsUzs7Z0NBZ0dHaUQsTzs7Z0NBSUhHLFMiLCJmaWxlIjoiVGV4dEZpZWxkLmpzIiwic291cmNlUm9vdCI6Ii9Vc2Vycy90bWFjX3pjL0NvZGUva3ItYWRtaW4iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHtDb21wb25lbnQsIFByb3BUeXBlc30gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgc2hhbGxvd0VxdWFsIGZyb20gJ3NoYWxsb3dlcXVhbCc7XG5pbXBvcnQgdHJhbnNpdGlvbnMgZnJvbSAnLi4vc3R5bGVzL3RyYW5zaXRpb25zJztcbmltcG9ydCBFbmhhbmNlZFRleHRhcmVhIGZyb20gJy4vRW5oYW5jZWRUZXh0YXJlYSc7XG5pbXBvcnQgVGV4dEZpZWxkSGludCBmcm9tICcuL1RleHRGaWVsZEhpbnQnO1xuaW1wb3J0IFRleHRGaWVsZExhYmVsIGZyb20gJy4vVGV4dEZpZWxkTGFiZWwnO1xuaW1wb3J0IFRleHRGaWVsZFVuZGVybGluZSBmcm9tICcuL1RleHRGaWVsZFVuZGVybGluZSc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcblxuY29uc3QgZ2V0U3R5bGVzID0gKHByb3BzLCBjb250ZXh0LCBzdGF0ZSkgPT4ge1xuICBjb25zdCB7XG4gICAgYmFzZVRoZW1lLFxuICAgIHRleHRGaWVsZDoge1xuICAgICAgZmxvYXRpbmdMYWJlbENvbG9yLFxuICAgICAgZm9jdXNDb2xvcixcbiAgICAgIHRleHRDb2xvcixcbiAgICAgIGRpc2FibGVkVGV4dENvbG9yLFxuICAgICAgYmFja2dyb3VuZENvbG9yLFxuICAgICAgZXJyb3JDb2xvcixcbiAgICB9LFxuICB9ID0gY29udGV4dC5tdWlUaGVtZTtcblxuICBjb25zdCBzdHlsZXMgPSB7XG4gICAgcm9vdDoge1xuICAgICAgZm9udFNpemU6IDE2LFxuICAgICAgbGluZUhlaWdodDogJzI0cHgnLFxuICAgICAgd2lkdGg6IHByb3BzLmZ1bGxXaWR0aCA/ICcxMDAlJyA6IDI1NixcbiAgICAgIGhlaWdodDogKHByb3BzLnJvd3MgLSAxKSAqIDI0ICsgKHByb3BzLmZsb2F0aW5nTGFiZWxUZXh0ID8gNzIgOiA0OCksXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgICBmb250RmFtaWx5OiBiYXNlVGhlbWUuZm9udEZhbWlseSxcbiAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb25zLmVhc2VPdXQoJzIwMG1zJywgJ2hlaWdodCcpLFxuICAgICAgY3Vyc29yOiBwcm9wcy5kaXNhYmxlZCA/ICdub3QtYWxsb3dlZCcgOiAnYXV0bycsXG4gICAgfSxcbiAgICBlcnJvcjoge1xuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICBib3R0b206IDIsXG4gICAgICBmb250U2l6ZTogMTIsXG4gICAgICBsaW5lSGVpZ2h0OiAnMTJweCcsXG4gICAgICBjb2xvcjogZXJyb3JDb2xvcixcbiAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb25zLmVhc2VPdXQoKSxcbiAgICB9LFxuICAgIGZsb2F0aW5nTGFiZWw6IHtcbiAgICAgIGNvbG9yOiBwcm9wcy5kaXNhYmxlZCA/IGRpc2FibGVkVGV4dENvbG9yIDogZmxvYXRpbmdMYWJlbENvbG9yLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgIH0sXG4gICAgaW5wdXQ6IHtcbiAgICAgIHBhZGRpbmc6IDAsXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgIG91dGxpbmU6ICdub25lJyxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgICAgY29sb3I6IHByb3BzLmRpc2FibGVkID8gZGlzYWJsZWRUZXh0Q29sb3IgOiB0ZXh0Q29sb3IsXG4gICAgICBjdXJzb3I6ICdpbmhlcml0JyxcbiAgICAgIGZvbnQ6ICdpbmhlcml0JyxcbiAgICAgIFdlYmtpdFRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKScsIC8vIFJlbW92ZSBtb2JpbGUgY29sb3IgZmxhc2hpbmcgKGRlcHJlY2F0ZWQgc3R5bGUpLlxuICAgIH0sXG4gICAgaW5wdXROYXRpdmU6IHtcbiAgICAgIGFwcGVhcmFuY2U6ICd0ZXh0ZmllbGQnLCAvLyBJbXByb3ZlIHR5cGUgc2VhcmNoIHN0eWxlLlxuICAgIH0sXG4gIH07XG5cbiAgc3R5bGVzLnRleHRhcmVhID0gT2JqZWN0LmFzc2lnbih7fSwgc3R5bGVzLmlucHV0LCB7XG4gICAgbWFyZ2luVG9wOiBwcm9wcy5mbG9hdGluZ0xhYmVsVGV4dCA/IDM2IDogMTIsXG4gICAgbWFyZ2luQm90dG9tOiBwcm9wcy5mbG9hdGluZ0xhYmVsVGV4dCA/IC0zNiA6IC0xMixcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICBmb250OiAnaW5oZXJpdCcsXG4gIH0pO1xuXG4gIC8vIERvIG5vdCBhc3NpZ24gYSBoZWlnaHQgdG8gdGhlIHRleHRhcmVhIGFzIGhlIGhhbmRsZXMgaXQgb24gaGlzIG93bi5cbiAgc3R5bGVzLmlucHV0LmhlaWdodCA9ICcxMDAlJztcblxuICBpZiAoc3RhdGUuaXNGb2N1c2VkKSB7XG4gICAgc3R5bGVzLmZsb2F0aW5nTGFiZWwuY29sb3IgPSBmb2N1c0NvbG9yO1xuICB9XG5cbiAgaWYgKHByb3BzLmZsb2F0aW5nTGFiZWxUZXh0KSB7XG4gICAgc3R5bGVzLmlucHV0LmJveFNpemluZyA9ICdib3JkZXItYm94JztcblxuICAgIGlmICghcHJvcHMubXVsdGlMaW5lKSB7XG4gICAgICBzdHlsZXMuaW5wdXQubWFyZ2luVG9wID0gMTQ7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmVycm9yVGV4dCkge1xuICAgICAgc3R5bGVzLmVycm9yLmJvdHRvbSA9ICFwcm9wcy5tdWx0aUxpbmUgPyBzdHlsZXMuZXJyb3IuZm9udFNpemUgKyAzIDogMztcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUuZXJyb3JUZXh0KSB7XG4gICAgaWYgKHN0YXRlLmlzRm9jdXNlZCkge1xuICAgICAgc3R5bGVzLmZsb2F0aW5nTGFiZWwuY29sb3IgPSBzdHlsZXMuZXJyb3IuY29sb3I7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0eWxlcztcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyB2YWxpZCB0byBiZSBkaXNwbGF5ZWQgaW5zaWRlIGFuIGlucHV0LlxuICpcbiAqIEBwYXJhbSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzdHJpbmcgcHJvdmlkZWQgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09ICcnICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbmNsYXNzIFRleHRGaWVsZCBleHRlbmRzIENvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgIC8qKlxuICAgICAqIFRoZSBjc3MgY2xhc3MgbmFtZSBvZiB0aGUgcm9vdCBlbGVtZW50LlxuICAgICAqL1xuICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dCBzdHJpbmcgdG8gdXNlIGZvciB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKi9cbiAgICBkZWZhdWx0VmFsdWU6IFByb3BUeXBlcy5hbnksXG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgdGhlIHRleHQgZmllbGQgaWYgc2V0IHRvIHRydWUuXG4gICAgICovXG4gICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIC8qKlxuICAgICAqIFRoZSBzdHlsZSBvYmplY3QgdG8gdXNlIHRvIG92ZXJyaWRlIGVycm9yIHN0eWxlcy5cbiAgICAgKi9cbiAgICBlcnJvclN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIC8qKlxuICAgICAqIFRoZSBlcnJvciBjb250ZW50IHRvIGRpc3BsYXkuXG4gICAgICovXG4gICAgZXJyb3JUZXh0OiBQcm9wVHlwZXMubm9kZSxcbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgZmxvYXRpbmcgbGFiZWwgd2lsbCBmbG9hdCBldmVuIHdoZW4gdGhlcmUgaXMgbm8gdmFsdWUuXG4gICAgICovXG4gICAgZmxvYXRpbmdMYWJlbEZpeGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAvKipcbiAgICAgKiBUaGUgc3R5bGUgb2JqZWN0IHRvIHVzZSB0byBvdmVycmlkZSBmbG9hdGluZyBsYWJlbCBzdHlsZXMgd2hlbiBmb2N1c2VkLlxuICAgICAqL1xuICAgIGZsb2F0aW5nTGFiZWxGb2N1c1N0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIC8qKlxuICAgICAqIFRoZSBzdHlsZSBvYmplY3QgdG8gdXNlIHRvIG92ZXJyaWRlIGZsb2F0aW5nIGxhYmVsIHN0eWxlcyB3aGVuIHNocnVuay5cbiAgICAgKi9cbiAgICBmbG9hdGluZ0xhYmVsU2hyaW5rU3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgLyoqXG4gICAgICogVGhlIHN0eWxlIG9iamVjdCB0byB1c2UgdG8gb3ZlcnJpZGUgZmxvYXRpbmcgbGFiZWwgc3R5bGVzLlxuICAgICAqL1xuICAgIGZsb2F0aW5nTGFiZWxTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAvKipcbiAgICAgKiBUaGUgY29udGVudCB0byB1c2UgZm9yIHRoZSBmbG9hdGluZyBsYWJlbCBlbGVtZW50LlxuICAgICAqL1xuICAgIGZsb2F0aW5nTGFiZWxUZXh0OiBQcm9wVHlwZXMubm9kZSxcbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgZmllbGQgcmVjZWl2ZXMgdGhlIHByb3BlcnR5IHdpZHRoIDEwMCUuXG4gICAgICovXG4gICAgZnVsbFdpZHRoOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGUgaW5saW5lLXN0eWxlcyBvZiB0aGUgVGV4dEZpZWxkJ3MgaGludCB0ZXh0IGVsZW1lbnQuXG4gICAgICovXG4gICAgaGludFN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIC8qKlxuICAgICAqIFRoZSBoaW50IGNvbnRlbnQgdG8gZGlzcGxheS5cbiAgICAgKi9cbiAgICBoaW50VGV4dDogUHJvcFR5cGVzLm5vZGUsXG4gICAgLyoqXG4gICAgICogVGhlIGlkIHByb3AgZm9yIHRoZSB0ZXh0IGZpZWxkLlxuICAgICAqL1xuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoZSBpbmxpbmUtc3R5bGVzIG9mIHRoZSBUZXh0RmllbGQncyBpbnB1dCBlbGVtZW50LlxuICAgICAqIFdoZW4gbXVsdGlMaW5lIGlzIGZhbHNlOiBkZWZpbmUgdGhlIHN0eWxlIG9mIHRoZSBpbnB1dCBlbGVtZW50LlxuICAgICAqIFdoZW4gbXVsdGlMaW5lIGlzIHRydWU6IGRlZmluZSB0aGUgc3R5bGUgb2YgdGhlIGNvbnRhaW5lciBvZiB0aGUgdGV4dGFyZWEuXG4gICAgICovXG4gICAgaW5wdXRTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBhIHRleHRhcmVhIGVsZW1lbnQgd2lsbCBiZSByZW5kZXJlZC5cbiAgICAgKiBUaGUgdGV4dGFyZWEgYWxzbyBncm93cyBhbmQgc2hyaW5rcyBhY2NvcmRpbmcgdG8gdGhlIG51bWJlciBvZiBsaW5lcy5cbiAgICAgKi9cbiAgICBtdWx0aUxpbmU6IFByb3BUeXBlcy5ib29sLFxuICAgIC8qKlxuICAgICAqIE5hbWUgYXBwbGllZCB0byB0aGUgaW5wdXQuXG4gICAgICovXG4gICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIG9uQmx1cjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBmaXJlZCB3aGVuIHRoZSB0ZXh0ZmllbGQncyB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqL1xuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIG9uRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkgd2hlbiBtdWx0aUxpbmUgb3B0aW9uIGlzIHNldCB0byB0cnVlLlxuICAgICAqL1xuICAgIHJvd3M6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgLyoqXG4gICAgICogTWF4aW11bSBudW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5IHdoZW5cbiAgICAgKiBtdWx0aUxpbmUgb3B0aW9uIGlzIHNldCB0byB0cnVlLlxuICAgICAqL1xuICAgIHJvd3NNYXg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhlIGlubGluZS1zdHlsZXMgb2YgdGhlIHJvb3QgZWxlbWVudC5cbiAgICAgKi9cbiAgICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGUgaW5saW5lLXN0eWxlcyBvZiB0aGUgVGV4dEZpZWxkJ3MgdGV4dGFyZWEgZWxlbWVudC5cbiAgICAgKiBUaGUgVGV4dEZpZWxkIHVzZSBlaXRoZXIgYSB0ZXh0YXJlYSBvciBhbiBpbnB1dCxcbiAgICAgKiB0aGlzIHByb3BlcnR5IGhhcyBlZmZlY3RzIG9ubHkgd2hlbiBtdWx0aUxpbmUgaXMgdHJ1ZS5cbiAgICAgKi9cbiAgICB0ZXh0YXJlYVN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgdHlwZSBvZiBpbnB1dCB0byBkaXNwbGF5XG4gICAgICogc3VjaCBhcyBcInBhc3N3b3JkXCIgb3IgXCJ0ZXh0XCIuXG4gICAgICovXG4gICAgdHlwZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGUgaW5saW5lLXN0eWxlcyBvZiB0aGVcbiAgICAgKiBUZXh0RmllbGQncyB1bmRlcmxpbmUgZWxlbWVudCB3aGVuIGRpc2FibGVkLlxuICAgICAqL1xuICAgIHVuZGVybGluZURpc2FibGVkU3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhlIGlubGluZS1zdHlsZXMgb2YgdGhlIFRleHRGaWVsZCdzXG4gICAgICogdW5kZXJsaW5lIGVsZW1lbnQgd2hlbiBmb2N1c3NlZC5cbiAgICAgKi9cbiAgICB1bmRlcmxpbmVGb2N1c1N0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHNob3dzIHRoZSB1bmRlcmxpbmUgZm9yIHRoZSB0ZXh0IGZpZWxkLlxuICAgICAqL1xuICAgIHVuZGVybGluZVNob3c6IFByb3BUeXBlcy5ib29sLFxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoZSBpbmxpbmUtc3R5bGVzIG9mIHRoZSBUZXh0RmllbGQncyB1bmRlcmxpbmUgZWxlbWVudC5cbiAgICAgKi9cbiAgICB1bmRlcmxpbmVTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgdGhlIHRleHQgZmllbGQuXG4gICAgICovXG4gICAgdmFsdWU6IFByb3BUeXBlcy5hbnksXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgZmxvYXRpbmdMYWJlbEZpeGVkOiBmYWxzZSxcbiAgICBtdWx0aUxpbmU6IGZhbHNlLFxuICAgIGZ1bGxXaWR0aDogZmFsc2UsXG4gICAgdHlwZTogJ3RleHQnLFxuICAgIHVuZGVybGluZVNob3c6IHRydWUsXG4gICAgcm93czogMSxcbiAgfTtcblxuICBzdGF0aWMgY29udGV4dFR5cGVzID0ge1xuICAgIG11aVRoZW1lOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIH07XG5cbiAgc3RhdGUgPSB7XG4gICAgaXNGb2N1c2VkOiBmYWxzZSxcbiAgICBlcnJvclRleHQ6IHVuZGVmaW5lZCxcbiAgICBoYXNWYWx1ZTogZmFsc2UsXG4gIH07XG5cbiAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgbmFtZSxcbiAgICAgIGhpbnRUZXh0LFxuICAgICAgZmxvYXRpbmdMYWJlbFRleHQsXG4gICAgICBpZCxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IHByb3BzTGVhZiA9IGNoaWxkcmVuID8gY2hpbGRyZW4ucHJvcHMgOiB0aGlzLnByb3BzO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBlcnJvclRleHQ6IHRoaXMucHJvcHMuZXJyb3JUZXh0LFxuICAgICAgaGFzVmFsdWU6IGlzVmFsaWQocHJvcHNMZWFmLnZhbHVlKSB8fCBpc1ZhbGlkKHByb3BzTGVhZi5kZWZhdWx0VmFsdWUpLFxuICAgIH0pO1xuXG4gICAgd2FybmluZyhuYW1lIHx8IGhpbnRUZXh0IHx8IGZsb2F0aW5nTGFiZWxUZXh0IHx8IGlkLCBgTWF0ZXJpYWwtVUk6IFdlIGRvbid0IGhhdmUgZW5vdWdoIGluZm9ybWF0aW9uXG4gICAgICB0byBidWlsZCBhIHJvYnVzdCB1bmlxdWUgaWQgZm9yIHRoZSBUZXh0RmllbGQgY29tcG9uZW50LiBQbGVhc2UgcHJvdmlkZSBhbiBpZCBvciBhIG5hbWUuYCk7XG5cbiAgICBjb25zdCB1bmlxdWVJZCA9IGAke25hbWV9LSR7aGludFRleHR9LSR7ZmxvYXRpbmdMYWJlbFRleHR9LSR7XG4gICAgICBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweEZGRkYpfWA7XG4gICAgdGhpcy51bmlxdWVJZCA9IHVuaXF1ZUlkLnJlcGxhY2UoL1teQS1aYS16MC05LV0vZ2ksICcnKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgaWYgKG5leHRQcm9wcy5lcnJvclRleHQgIT09IHRoaXMucHJvcHMuZXJyb3JUZXh0KSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZXJyb3JUZXh0OiBuZXh0UHJvcHMuZXJyb3JUZXh0LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG5leHRQcm9wcy5jaGlsZHJlbiAmJiBuZXh0UHJvcHMuY2hpbGRyZW4ucHJvcHMpIHtcbiAgICAgIG5leHRQcm9wcyA9IG5leHRQcm9wcy5jaGlsZHJlbi5wcm9wcztcbiAgICB9XG5cbiAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG4gICAgICBjb25zdCBoYXNWYWx1ZSA9IGlzVmFsaWQobmV4dFByb3BzLnZhbHVlKTtcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGhhc1ZhbHVlOiBoYXNWYWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgIXNoYWxsb3dFcXVhbCh0aGlzLnByb3BzLCBuZXh0UHJvcHMpIHx8XG4gICAgICAhc2hhbGxvd0VxdWFsKHRoaXMuc3RhdGUsIG5leHRTdGF0ZSkgfHxcbiAgICAgICFzaGFsbG93RXF1YWwodGhpcy5jb250ZXh0LCBuZXh0Q29udGV4dClcbiAgICApO1xuICB9XG5cbiAgYmx1cigpIHtcbiAgICBpZiAodGhpcy5pbnB1dCkge1xuICAgICAgdGhpcy5nZXRJbnB1dE5vZGUoKS5ibHVyKCk7XG4gICAgfVxuICB9XG5cbiAgZm9jdXMoKSB7XG4gICAgaWYgKHRoaXMuaW5wdXQpIHtcbiAgICAgIHRoaXMuZ2V0SW5wdXROb2RlKCkuZm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICBzZWxlY3QoKSB7XG4gICAgaWYgKHRoaXMuaW5wdXQpIHtcbiAgICAgIHRoaXMuZ2V0SW5wdXROb2RlKCkuc2VsZWN0KCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXQgPyB0aGlzLmdldElucHV0Tm9kZSgpLnZhbHVlIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgZ2V0SW5wdXROb2RlKCkge1xuICAgIHJldHVybiAodGhpcy5wcm9wcy5jaGlsZHJlbiB8fCB0aGlzLnByb3BzLm11bHRpTGluZSkgP1xuICAgICAgdGhpcy5pbnB1dC5nZXRJbnB1dE5vZGUoKSA6IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMuaW5wdXQpO1xuICB9XG5cbiAgaGFuZGxlSW5wdXRCbHVyID0gKGV2ZW50KSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7aXNGb2N1c2VkOiBmYWxzZX0pO1xuICAgIGlmICh0aGlzLnByb3BzLm9uQmx1cikge1xuICAgICAgdGhpcy5wcm9wcy5vbkJsdXIoZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVJbnB1dENoYW5nZSA9IChldmVudCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe2hhc1ZhbHVlOiBpc1ZhbGlkKGV2ZW50LnRhcmdldC52YWx1ZSl9KTtcbiAgICBpZiAodGhpcy5wcm9wcy5vbkNoYW5nZSkge1xuICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShldmVudCwgZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlSW5wdXRGb2N1cyA9IChldmVudCkgPT4ge1xuICAgIGlmICh0aGlzLnByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdGUoe2lzRm9jdXNlZDogdHJ1ZX0pO1xuICAgIGlmICh0aGlzLnByb3BzLm9uRm9jdXMpIHtcbiAgICAgIHRoaXMucHJvcHMub25Gb2N1cyhldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZUhlaWdodENoYW5nZSA9IChldmVudCwgaGVpZ2h0KSA9PiB7XG4gICAgbGV0IG5ld0hlaWdodCA9IGhlaWdodCArIDI0O1xuICAgIGlmICh0aGlzLnByb3BzLmZsb2F0aW5nTGFiZWxUZXh0KSB7XG4gICAgICBuZXdIZWlnaHQgKz0gMjQ7XG4gICAgfVxuICAgIFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpLnN0eWxlLmhlaWdodCA9IGAke25ld0hlaWdodH1weGA7XG4gIH07XG5cbiAgX2lzQ29udHJvbGxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIGRpc2FibGVkLFxuICAgICAgZXJyb3JTdHlsZSxcbiAgICAgIGVycm9yVGV4dCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgZmxvYXRpbmdMYWJlbEZpeGVkLFxuICAgICAgZmxvYXRpbmdMYWJlbEZvY3VzU3R5bGUsXG4gICAgICBmbG9hdGluZ0xhYmVsU2hyaW5rU3R5bGUsXG4gICAgICBmbG9hdGluZ0xhYmVsU3R5bGUsXG4gICAgICBmbG9hdGluZ0xhYmVsVGV4dCxcbiAgICAgIGZ1bGxXaWR0aCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgaGludFRleHQsXG4gICAgICBoaW50U3R5bGUsXG4gICAgICBpZCxcbiAgICAgIGlucHV0U3R5bGUsXG4gICAgICBtdWx0aUxpbmUsXG4gICAgICBvbkJsdXIsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIG9uQ2hhbmdlLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBvbkZvY3VzLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBzdHlsZSxcbiAgICAgIHR5cGUsXG4gICAgICB1bmRlcmxpbmVEaXNhYmxlZFN0eWxlLFxuICAgICAgdW5kZXJsaW5lRm9jdXNTdHlsZSxcbiAgICAgIHVuZGVybGluZVNob3csXG4gICAgICB1bmRlcmxpbmVTdHlsZSxcbiAgICAgIHJvd3MsXG4gICAgICByb3dzTWF4LFxuICAgICAgdGV4dGFyZWFTdHlsZSxcbiAgICAgIC4uLm90aGVyXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCB7cHJlcGFyZVN0eWxlc30gPSB0aGlzLmNvbnRleHQubXVpVGhlbWU7XG4gICAgY29uc3Qgc3R5bGVzID0gZ2V0U3R5bGVzKHRoaXMucHJvcHMsIHRoaXMuY29udGV4dCwgdGhpcy5zdGF0ZSk7XG4gICAgY29uc3QgaW5wdXRJZCA9IGlkIHx8IHRoaXMudW5pcXVlSWQ7XG5cbiAgICBjb25zdCBlcnJvclRleHRFbGVtZW50ID0gdGhpcy5zdGF0ZS5lcnJvclRleHQgJiYgKFxuICAgICAgPGRpdiBzdHlsZT17cHJlcGFyZVN0eWxlcyhPYmplY3QuYXNzaWduKHN0eWxlcy5lcnJvciwgZXJyb3JTdHlsZSkpfT5cbiAgICAgICAge3RoaXMuc3RhdGUuZXJyb3JUZXh0fVxuICAgICAgPC9kaXY+XG4gICAgKTtcblxuICAgIGNvbnN0IGZsb2F0aW5nTGFiZWxUZXh0RWxlbWVudCA9IGZsb2F0aW5nTGFiZWxUZXh0ICYmIChcbiAgICAgIDxUZXh0RmllbGRMYWJlbFxuICAgICAgICBtdWlUaGVtZT17dGhpcy5jb250ZXh0Lm11aVRoZW1lfVxuICAgICAgICBzdHlsZT17T2JqZWN0LmFzc2lnbihcbiAgICAgICAgICBzdHlsZXMuZmxvYXRpbmdMYWJlbCxcbiAgICAgICAgICBmbG9hdGluZ0xhYmVsU3R5bGUsXG4gICAgICAgICAgdGhpcy5zdGF0ZS5pc0ZvY3VzZWQgPyBmbG9hdGluZ0xhYmVsRm9jdXNTdHlsZSA6IG51bGxcbiAgICAgICAgKX1cbiAgICAgICAgc2hyaW5rU3R5bGU9e2Zsb2F0aW5nTGFiZWxTaHJpbmtTdHlsZX1cbiAgICAgICAgaHRtbEZvcj17aW5wdXRJZH1cbiAgICAgICAgc2hyaW5rPXt0aGlzLnN0YXRlLmhhc1ZhbHVlIHx8IHRoaXMuc3RhdGUuaXNGb2N1c2VkIHx8IGZsb2F0aW5nTGFiZWxGaXhlZH1cbiAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgPlxuICAgICAgICB7ZmxvYXRpbmdMYWJlbFRleHR9XG4gICAgICA8L1RleHRGaWVsZExhYmVsPlxuICAgICk7XG5cbiAgICBjb25zdCBpbnB1dFByb3BzID0ge1xuICAgICAgaWQ6IGlucHV0SWQsXG4gICAgICByZWY6IChlbGVtKSA9PiB0aGlzLmlucHV0ID0gZWxlbSxcbiAgICAgIGRpc2FibGVkOiB0aGlzLnByb3BzLmRpc2FibGVkLFxuICAgICAgb25CbHVyOiB0aGlzLmhhbmRsZUlucHV0Qmx1cixcbiAgICAgIG9uQ2hhbmdlOiB0aGlzLmhhbmRsZUlucHV0Q2hhbmdlLFxuICAgICAgb25Gb2N1czogdGhpcy5oYW5kbGVJbnB1dEZvY3VzLFxuICAgIH07XG5cbiAgICBjb25zdCBjaGlsZFN0eWxlTWVyZ2VkID0gT2JqZWN0LmFzc2lnbihzdHlsZXMuaW5wdXQsIGlucHV0U3R5bGUpO1xuXG4gICAgbGV0IGlucHV0RWxlbWVudDtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGlucHV0RWxlbWVudCA9IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZHJlbixcbiAgICAgICAge1xuICAgICAgICAgIC4uLmlucHV0UHJvcHMsXG4gICAgICAgICAgLi4uY2hpbGRyZW4ucHJvcHMsXG4gICAgICAgICAgc3R5bGU6IE9iamVjdC5hc3NpZ24oY2hpbGRTdHlsZU1lcmdlZCwgY2hpbGRyZW4ucHJvcHMuc3R5bGUpLFxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXRFbGVtZW50ID0gbXVsdGlMaW5lID8gKFxuICAgICAgICA8RW5oYW5jZWRUZXh0YXJlYVxuICAgICAgICAgIHN0eWxlPXtjaGlsZFN0eWxlTWVyZ2VkfVxuICAgICAgICAgIHRleHRhcmVhU3R5bGU9e09iamVjdC5hc3NpZ24oc3R5bGVzLnRleHRhcmVhLCBzdHlsZXMuaW5wdXROYXRpdmUsIHRleHRhcmVhU3R5bGUpfVxuICAgICAgICAgIHJvd3M9e3Jvd3N9XG4gICAgICAgICAgcm93c01heD17cm93c01heH1cbiAgICAgICAgICB7Li4ub3RoZXJ9XG4gICAgICAgICAgey4uLmlucHV0UHJvcHN9XG4gICAgICAgICAgb25IZWlnaHRDaGFuZ2U9e3RoaXMuaGFuZGxlSGVpZ2h0Q2hhbmdlfVxuICAgICAgICAvPlxuICAgICAgKSA6IChcbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgdHlwZT17dHlwZX1cbiAgICAgICAgICBzdHlsZT17cHJlcGFyZVN0eWxlcyhPYmplY3QuYXNzaWduKHN0eWxlcy5pbnB1dE5hdGl2ZSwgY2hpbGRTdHlsZU1lcmdlZCkpfVxuICAgICAgICAgIHsuLi5vdGhlcn1cbiAgICAgICAgICB7Li4uaW5wdXRQcm9wc31cbiAgICAgICAgLz5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHJvb3RQcm9wcyA9IHt9O1xuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICByb290UHJvcHMgPSBvdGhlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICB7Li4ucm9vdFByb3BzfVxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgICAgc3R5bGU9e3ByZXBhcmVTdHlsZXMoT2JqZWN0LmFzc2lnbihzdHlsZXMucm9vdCwgc3R5bGUpKX1cbiAgICAgID5cbiAgICAgICAge2Zsb2F0aW5nTGFiZWxUZXh0RWxlbWVudH1cbiAgICAgICAge2hpbnRUZXh0ID9cbiAgICAgICAgICA8VGV4dEZpZWxkSGludFxuICAgICAgICAgICAgbXVpVGhlbWU9e3RoaXMuY29udGV4dC5tdWlUaGVtZX1cbiAgICAgICAgICAgIHNob3c9eyEodGhpcy5zdGF0ZS5oYXNWYWx1ZSB8fCAoZmxvYXRpbmdMYWJlbFRleHQgJiYgIXRoaXMuc3RhdGUuaXNGb2N1c2VkKSkgfHxcbiAgICAgICAgICAgICAgICAgICghdGhpcy5zdGF0ZS5oYXNWYWx1ZSAmJiBmbG9hdGluZ0xhYmVsVGV4dCAmJiBmbG9hdGluZ0xhYmVsRml4ZWQgJiYgIXRoaXMuc3RhdGUuaXNGb2N1c2VkKX1cbiAgICAgICAgICAgIHN0eWxlPXtoaW50U3R5bGV9XG4gICAgICAgICAgICB0ZXh0PXtoaW50VGV4dH1cbiAgICAgICAgICAvPiA6XG4gICAgICAgICAgbnVsbFxuICAgICAgICB9XG4gICAgICAgIHtpbnB1dEVsZW1lbnR9XG4gICAgICAgIHt1bmRlcmxpbmVTaG93ID9cbiAgICAgICAgICA8VGV4dEZpZWxkVW5kZXJsaW5lXG4gICAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICAgICAgICBkaXNhYmxlZFN0eWxlPXt1bmRlcmxpbmVEaXNhYmxlZFN0eWxlfVxuICAgICAgICAgICAgZXJyb3I9eyEhdGhpcy5zdGF0ZS5lcnJvclRleHR9XG4gICAgICAgICAgICBlcnJvclN0eWxlPXtlcnJvclN0eWxlfVxuICAgICAgICAgICAgZm9jdXM9e3RoaXMuc3RhdGUuaXNGb2N1c2VkfVxuICAgICAgICAgICAgZm9jdXNTdHlsZT17dW5kZXJsaW5lRm9jdXNTdHlsZX1cbiAgICAgICAgICAgIG11aVRoZW1lPXt0aGlzLmNvbnRleHQubXVpVGhlbWV9XG4gICAgICAgICAgICBzdHlsZT17dW5kZXJsaW5lU3R5bGV9XG4gICAgICAgICAgLz4gOlxuICAgICAgICAgIG51bGxcbiAgICAgICAgfVxuICAgICAgICB7ZXJyb3JUZXh0RWxlbWVudH1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dEZpZWxkO1xuIl19