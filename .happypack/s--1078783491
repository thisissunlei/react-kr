'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _simpleAssign = require('simple-assign');

var _simpleAssign2 = _interopRequireDefault(_simpleAssign);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _childUtils = require('../utils/childUtils');

var _events = require('../utils/events');

var _events2 = _interopRequireDefault(_events);

var _keycode = require('keycode');

var _keycode2 = _interopRequireDefault(_keycode);

var _FocusRipple = require('./FocusRipple');

var _FocusRipple2 = _interopRequireDefault(_FocusRipple);

var _TouchRipple = require('./TouchRipple');

var _TouchRipple2 = _interopRequireDefault(_TouchRipple);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var styleInjected = false;
var listening = false;
var tabPressed = false;

function injectStyle() {
  if (!styleInjected) {
    // Remove inner padding and border in Firefox 4+.
    var style = document.createElement('style');
    style.innerHTML = '\n      button::-moz-focus-inner,\n      input::-moz-focus-inner {\n        border: 0;\n        padding: 0;\n      }\n    ';

    document.body.appendChild(style);
    styleInjected = true;
  }
}

function listenForTabPresses() {
  if (!listening) {
    _events2.default.on(window, 'keydown', function (event) {
      tabPressed = (0, _keycode2.default)(event) === 'tab';
    });
    listening = true;
  }
}

var EnhancedButton = function (_Component) {
  _inherits(EnhancedButton, _Component);

  function EnhancedButton() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, EnhancedButton);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = EnhancedButton.__proto__ || Object.getPrototypeOf(EnhancedButton)).call.apply(_ref, [this].concat(args))), _this), _this.state = { isKeyboardFocused: false }, _this.handleKeyDown = function (event) {
      if (!_this.props.disabled && !_this.props.disableKeyboardFocus) {
        if ((0, _keycode2.default)(event) === 'enter' && _this.state.isKeyboardFocused) {
          _this.handleTouchTap(event);
        }
        if ((0, _keycode2.default)(event) === 'esc' && _this.state.isKeyboardFocused) {
          _this.removeKeyboardFocus(event);
        }
      }
      _this.props.onKeyDown(event);
    }, _this.handleKeyUp = function (event) {
      if (!_this.props.disabled && !_this.props.disableKeyboardFocus) {
        if ((0, _keycode2.default)(event) === 'space' && _this.state.isKeyboardFocused) {
          _this.handleTouchTap(event);
        }
      }
      _this.props.onKeyUp(event);
    }, _this.handleBlur = function (event) {
      _this.cancelFocusTimeout();
      _this.removeKeyboardFocus(event);
      _this.props.onBlur(event);
    }, _this.handleFocus = function (event) {
      if (event) event.persist();
      if (!_this.props.disabled && !_this.props.disableKeyboardFocus) {
        // setTimeout is needed because the focus event fires first
        // Wait so that we can capture if this was a keyboard focus
        // or touch focus
        _this.focusTimeout = setTimeout(function () {
          if (tabPressed) {
            _this.setKeyboardFocus(event);
            tabPressed = false;
          }
        }, 150);

        _this.props.onFocus(event);
      }
    }, _this.handleClick = function (event) {
      if (!_this.props.disabled) {
        tabPressed = false;
        _this.props.onClick(event);
      }
    }, _this.handleTouchTap = function (event) {
      _this.cancelFocusTimeout();
      if (!_this.props.disabled) {
        tabPressed = false;
        _this.removeKeyboardFocus(event);
        _this.props.onTouchTap(event);
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(EnhancedButton, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      var _props = this.props,
          disabled = _props.disabled,
          disableKeyboardFocus = _props.disableKeyboardFocus,
          keyboardFocused = _props.keyboardFocused;

      if (!disabled && keyboardFocused && !disableKeyboardFocus) {
        this.setState({ isKeyboardFocused: true });
      }
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      injectStyle();
      listenForTabPresses();
      if (this.state.isKeyboardFocused) {
        this.refs.enhancedButton.focus();
        this.props.onKeyboardFocus(null, true);
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if ((nextProps.disabled || nextProps.disableKeyboardFocus) && this.state.isKeyboardFocused) {
        this.setState({ isKeyboardFocused: false });
        if (nextProps.onKeyboardFocus) {
          nextProps.onKeyboardFocus(null, false);
        }
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      clearTimeout(this.focusTimeout);
    }
  }, {
    key: 'isKeyboardFocused',
    value: function isKeyboardFocused() {
      return this.state.isKeyboardFocused;
    }
  }, {
    key: 'removeKeyboardFocus',
    value: function removeKeyboardFocus(event) {
      if (this.state.isKeyboardFocused) {
        this.setState({ isKeyboardFocused: false });
        this.props.onKeyboardFocus(event, false);
      }
    }
  }, {
    key: 'setKeyboardFocus',
    value: function setKeyboardFocus(event) {
      if (!this.state.isKeyboardFocused) {
        this.setState({ isKeyboardFocused: true });
        this.props.onKeyboardFocus(event, true);
      }
    }
  }, {
    key: 'cancelFocusTimeout',
    value: function cancelFocusTimeout() {
      if (this.focusTimeout) {
        clearTimeout(this.focusTimeout);
        this.focusTimeout = null;
      }
    }
  }, {
    key: 'createButtonChildren',
    value: function createButtonChildren() {
      var _props2 = this.props,
          centerRipple = _props2.centerRipple,
          children = _props2.children,
          disabled = _props2.disabled,
          disableFocusRipple = _props2.disableFocusRipple,
          disableKeyboardFocus = _props2.disableKeyboardFocus,
          disableTouchRipple = _props2.disableTouchRipple,
          focusRippleColor = _props2.focusRippleColor,
          focusRippleOpacity = _props2.focusRippleOpacity,
          touchRippleColor = _props2.touchRippleColor,
          touchRippleOpacity = _props2.touchRippleOpacity;
      var isKeyboardFocused = this.state.isKeyboardFocused;

      // Focus Ripple

      var focusRipple = isKeyboardFocused && !disabled && !disableFocusRipple && !disableKeyboardFocus ? _react2.default.createElement(_FocusRipple2.default, {
        color: focusRippleColor,
        opacity: focusRippleOpacity,
        show: isKeyboardFocused
      }) : undefined;

      // Touch Ripple
      var touchRipple = !disabled && !disableTouchRipple ? _react2.default.createElement(
        _TouchRipple2.default,
        {
          centerRipple: centerRipple,
          color: touchRippleColor,
          opacity: touchRippleOpacity
        },
        children
      ) : undefined;

      return (0, _childUtils.createChildFragment)({
        focusRipple: focusRipple,
        touchRipple: touchRipple,
        children: touchRipple ? undefined : children
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _props3 = this.props,
          centerRipple = _props3.centerRipple,
          children = _props3.children,
          containerElement = _props3.containerElement,
          disabled = _props3.disabled,
          disableFocusRipple = _props3.disableFocusRipple,
          disableKeyboardFocus = _props3.disableKeyboardFocus,
          disableTouchRipple = _props3.disableTouchRipple,
          focusRippleColor = _props3.focusRippleColor,
          focusRippleOpacity = _props3.focusRippleOpacity,
          href = _props3.href,
          keyboardFocused = _props3.keyboardFocused,
          touchRippleColor = _props3.touchRippleColor,
          touchRippleOpacity = _props3.touchRippleOpacity,
          onBlur = _props3.onBlur,
          onClick = _props3.onClick,
          onFocus = _props3.onFocus,
          onKeyUp = _props3.onKeyUp,
          onKeyDown = _props3.onKeyDown,
          onKeyboardFocus = _props3.onKeyboardFocus,
          onTouchTap = _props3.onTouchTap,
          style = _props3.style,
          tabIndex = _props3.tabIndex,
          type = _props3.type,
          other = _objectWithoutProperties(_props3, ['centerRipple', 'children', 'containerElement', 'disabled', 'disableFocusRipple', 'disableKeyboardFocus', 'disableTouchRipple', 'focusRippleColor', 'focusRippleOpacity', 'href', 'keyboardFocused', 'touchRippleColor', 'touchRippleOpacity', 'onBlur', 'onClick', 'onFocus', 'onKeyUp', 'onKeyDown', 'onKeyboardFocus', 'onTouchTap', 'style', 'tabIndex', 'type']);

      var _context$muiTheme = this.context.muiTheme,
          prepareStyles = _context$muiTheme.prepareStyles,
          enhancedButton = _context$muiTheme.enhancedButton;


      var mergedStyles = (0, _simpleAssign2.default)({
        border: 10,
        boxSizing: 'border-box',
        display: 'inline-block',
        fontFamily: this.context.muiTheme.baseTheme.fontFamily,
        WebkitTapHighlightColor: enhancedButton.tapHighlightColor, // Remove mobile color flashing (deprecated)
        cursor: disabled ? 'default' : 'pointer',
        textDecoration: 'none',
        margin: 0,
        padding: 0,
        outline: 'none',
        fontSize: 'inherit',
        fontWeight: 'inherit',
        /**
         * This is needed so that ripples do not bleed
         * past border radius.
         * See: http://stackoverflow.com/questions/17298739/
         * css-overflow-hidden-not-working-in-chrome-when-parent-has-border-radius-and-chil
         */
        transform: disableTouchRipple && disableFocusRipple ? null : 'translate(0, 0)',
        verticalAlign: href ? 'middle' : null
      }, style);

      // Passing both background:none & backgroundColor can break due to object iteration order
      if (!mergedStyles.backgroundColor && !mergedStyles.background) {
        mergedStyles.background = 'none';
      }

      if (disabled && href) {
        return _react2.default.createElement(
          'span',
          _extends({}, other, {
            style: mergedStyles
          }),
          children
        );
      }

      var buttonProps = _extends({}, other, {
        style: prepareStyles(mergedStyles),
        ref: 'enhancedButton',
        disabled: disabled,
        href: href,
        onBlur: this.handleBlur,
        onClick: this.handleClick,
        onFocus: this.handleFocus,
        onKeyUp: this.handleKeyUp,
        onKeyDown: this.handleKeyDown,
        onTouchTap: this.handleTouchTap,
        tabIndex: disabled || disableKeyboardFocus ? -1 : tabIndex,
        type: type
      });
      var buttonChildren = this.createButtonChildren();

      if (_react2.default.isValidElement(containerElement)) {
        return _react2.default.cloneElement(containerElement, buttonProps, buttonChildren);
      }

      return _react2.default.createElement(href ? 'a' : containerElement, buttonProps, buttonChildren);
    }
  }]);

  return EnhancedButton;
}(_react.Component);

EnhancedButton.propTypes = {
  centerRipple: _react.PropTypes.bool,
  children: _react.PropTypes.node,
  containerElement: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.element]),
  disableFocusRipple: _react.PropTypes.bool,
  disableKeyboardFocus: _react.PropTypes.bool,
  disableTouchRipple: _react.PropTypes.bool,
  disabled: _react.PropTypes.bool,
  focusRippleColor: _react.PropTypes.string,
  focusRippleOpacity: _react.PropTypes.number,
  href: _react.PropTypes.string,
  keyboardFocused: _react.PropTypes.bool,
  onBlur: _react.PropTypes.func,
  onClick: _react.PropTypes.func,
  onFocus: _react.PropTypes.func,
  onKeyDown: _react.PropTypes.func,
  onKeyUp: _react.PropTypes.func,
  onKeyboardFocus: _react.PropTypes.func,
  onMouseDown: _react.PropTypes.func,
  onMouseEnter: _react.PropTypes.func,
  onMouseLeave: _react.PropTypes.func,
  onMouseUp: _react.PropTypes.func,
  onTouchEnd: _react.PropTypes.func,
  onTouchStart: _react.PropTypes.func,
  onTouchTap: _react.PropTypes.func,
  style: _react.PropTypes.object,
  tabIndex: _react.PropTypes.number,
  touchRippleColor: _react.PropTypes.string,
  touchRippleOpacity: _react.PropTypes.number,
  type: _react.PropTypes.string
};
EnhancedButton.defaultProps = {
  containerElement: 'button',
  onBlur: function onBlur() {},
  onClick: function onClick() {},
  onFocus: function onFocus() {},
  onKeyDown: function onKeyDown() {},
  onKeyUp: function onKeyUp() {},
  onKeyboardFocus: function onKeyboardFocus() {},
  onMouseDown: function onMouseDown() {},
  onMouseEnter: function onMouseEnter() {},
  onMouseLeave: function onMouseLeave() {},
  onMouseUp: function onMouseUp() {},
  onTouchEnd: function onTouchEnd() {},
  onTouchStart: function onTouchStart() {},
  onTouchTap: function onTouchTap() {},
  tabIndex: 0,
  type: 'button'
};
EnhancedButton.contextTypes = {
  muiTheme: _react.PropTypes.object.isRequired
};
var _default = EnhancedButton;
exports.default = _default;
;

var _temp2 = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(styleInjected, 'styleInjected', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/internal/EnhancedButton.js');

  __REACT_HOT_LOADER__.register(listening, 'listening', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/internal/EnhancedButton.js');

  __REACT_HOT_LOADER__.register(tabPressed, 'tabPressed', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/internal/EnhancedButton.js');

  __REACT_HOT_LOADER__.register(injectStyle, 'injectStyle', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/internal/EnhancedButton.js');

  __REACT_HOT_LOADER__.register(listenForTabPresses, 'listenForTabPresses', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/internal/EnhancedButton.js');

  __REACT_HOT_LOADER__.register(EnhancedButton, 'EnhancedButton', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/internal/EnhancedButton.js');

  __REACT_HOT_LOADER__.register(_default, 'default', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/internal/EnhancedButton.js');
}();

;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9Db21wb25lbnRzL0RhdGVQaWNrZXIvaW50ZXJuYWwvRW5oYW5jZWRCdXR0b24uanMiXSwibmFtZXMiOlsic3R5bGVJbmplY3RlZCIsImxpc3RlbmluZyIsInRhYlByZXNzZWQiLCJpbmplY3RTdHlsZSIsInN0eWxlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaW5uZXJIVE1MIiwiYm9keSIsImFwcGVuZENoaWxkIiwibGlzdGVuRm9yVGFiUHJlc3NlcyIsIm9uIiwid2luZG93IiwiZXZlbnQiLCJFbmhhbmNlZEJ1dHRvbiIsInN0YXRlIiwiaXNLZXlib2FyZEZvY3VzZWQiLCJoYW5kbGVLZXlEb3duIiwicHJvcHMiLCJkaXNhYmxlZCIsImRpc2FibGVLZXlib2FyZEZvY3VzIiwiaGFuZGxlVG91Y2hUYXAiLCJyZW1vdmVLZXlib2FyZEZvY3VzIiwib25LZXlEb3duIiwiaGFuZGxlS2V5VXAiLCJvbktleVVwIiwiaGFuZGxlQmx1ciIsImNhbmNlbEZvY3VzVGltZW91dCIsIm9uQmx1ciIsImhhbmRsZUZvY3VzIiwicGVyc2lzdCIsImZvY3VzVGltZW91dCIsInNldFRpbWVvdXQiLCJzZXRLZXlib2FyZEZvY3VzIiwib25Gb2N1cyIsImhhbmRsZUNsaWNrIiwib25DbGljayIsIm9uVG91Y2hUYXAiLCJrZXlib2FyZEZvY3VzZWQiLCJzZXRTdGF0ZSIsInJlZnMiLCJlbmhhbmNlZEJ1dHRvbiIsImZvY3VzIiwib25LZXlib2FyZEZvY3VzIiwibmV4dFByb3BzIiwiY2xlYXJUaW1lb3V0IiwiY2VudGVyUmlwcGxlIiwiY2hpbGRyZW4iLCJkaXNhYmxlRm9jdXNSaXBwbGUiLCJkaXNhYmxlVG91Y2hSaXBwbGUiLCJmb2N1c1JpcHBsZUNvbG9yIiwiZm9jdXNSaXBwbGVPcGFjaXR5IiwidG91Y2hSaXBwbGVDb2xvciIsInRvdWNoUmlwcGxlT3BhY2l0eSIsImZvY3VzUmlwcGxlIiwidW5kZWZpbmVkIiwidG91Y2hSaXBwbGUiLCJjb250YWluZXJFbGVtZW50IiwiaHJlZiIsInRhYkluZGV4IiwidHlwZSIsIm90aGVyIiwiY29udGV4dCIsIm11aVRoZW1lIiwicHJlcGFyZVN0eWxlcyIsIm1lcmdlZFN0eWxlcyIsImJvcmRlciIsImJveFNpemluZyIsImRpc3BsYXkiLCJmb250RmFtaWx5IiwiYmFzZVRoZW1lIiwiV2Via2l0VGFwSGlnaGxpZ2h0Q29sb3IiLCJ0YXBIaWdobGlnaHRDb2xvciIsImN1cnNvciIsInRleHREZWNvcmF0aW9uIiwibWFyZ2luIiwicGFkZGluZyIsIm91dGxpbmUiLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJ0cmFuc2Zvcm0iLCJ2ZXJ0aWNhbEFsaWduIiwiYmFja2dyb3VuZENvbG9yIiwiYmFja2dyb3VuZCIsImJ1dHRvblByb3BzIiwicmVmIiwiYnV0dG9uQ2hpbGRyZW4iLCJjcmVhdGVCdXR0b25DaGlsZHJlbiIsImlzVmFsaWRFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwicHJvcFR5cGVzIiwiYm9vbCIsIm5vZGUiLCJvbmVPZlR5cGUiLCJzdHJpbmciLCJlbGVtZW50IiwibnVtYmVyIiwiZnVuYyIsIm9uTW91c2VEb3duIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwib25Nb3VzZVVwIiwib25Ub3VjaEVuZCIsIm9uVG91Y2hTdGFydCIsIm9iamVjdCIsImRlZmF1bHRQcm9wcyIsImNvbnRleHRUeXBlcyIsImlzUmVxdWlyZWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFJQSxnQkFBZ0IsS0FBcEI7QUFDQSxJQUFJQyxZQUFZLEtBQWhCO0FBQ0EsSUFBSUMsYUFBYSxLQUFqQjs7QUFFQSxTQUFTQyxXQUFULEdBQXVCO0FBQ3JCLE1BQUksQ0FBQ0gsYUFBTCxFQUFvQjtBQUNsQjtBQUNBLFFBQU1JLFFBQVFDLFNBQVNDLGFBQVQsQ0FBdUIsT0FBdkIsQ0FBZDtBQUNBRixVQUFNRyxT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VSxDQWZVO0FBZ0JwQkMsUUFBTTtBQWhCYyxDO0FBcENsQjlDLGMsQ0F1REc0RixZLEdBQWU7QUFDcEIzQyxZQUFVLGlCQUFVeUMsTUFBVixDQUFpQkc7QUFEUCxDO2VBcVFUN0YsYzs7Ozs7Ozs7O2dDQTFWWGQsYTs7Z0NBQ0FDLFM7O2dDQUNBQyxVOztnQ0FFS0MsVzs7Z0NBaUJBTyxtQjs7Z0NBU0hJLGMiLCJmaWxlIjoiRW5oYW5jZWRCdXR0b24uanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL3RtYWNfemMvQ29kZS9rci1hZG1pbiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwge0NvbXBvbmVudCwgUHJvcFR5cGVzfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQge2NyZWF0ZUNoaWxkRnJhZ21lbnR9IGZyb20gJy4uL3V0aWxzL2NoaWxkVXRpbHMnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi91dGlscy9ldmVudHMnO1xuaW1wb3J0IGtleWNvZGUgZnJvbSAna2V5Y29kZSc7XG5pbXBvcnQgRm9jdXNSaXBwbGUgZnJvbSAnLi9Gb2N1c1JpcHBsZSc7XG5pbXBvcnQgVG91Y2hSaXBwbGUgZnJvbSAnLi9Ub3VjaFJpcHBsZSc7XG5cbmxldCBzdHlsZUluamVjdGVkID0gZmFsc2U7XG5sZXQgbGlzdGVuaW5nID0gZmFsc2U7XG5sZXQgdGFiUHJlc3NlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbmplY3RTdHlsZSgpIHtcbiAgaWYgKCFzdHlsZUluamVjdGVkKSB7XG4gICAgLy8gUmVtb3ZlIGlubmVyIHBhZGRpbmcgYW5kIGJvcmRlciBpbiBGaXJlZm94IDQrLlxuICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZS5pbm5lckhUTUwgPSBgXG4gICAgICBidXR0b246Oi1tb3otZm9jdXMtaW5uZXIsXG4gICAgICBpbnB1dDo6LW1vei1mb2N1cy1pbm5lciB7XG4gICAgICAgIGJvcmRlcjogMDtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgIH1cbiAgICBgO1xuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgc3R5bGVJbmplY3RlZCA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGlzdGVuRm9yVGFiUHJlc3NlcygpIHtcbiAgaWYgKCFsaXN0ZW5pbmcpIHtcbiAgICBFdmVudHMub24od2luZG93LCAna2V5ZG93bicsIChldmVudCkgPT4ge1xuICAgICAgdGFiUHJlc3NlZCA9IGtleWNvZGUoZXZlbnQpID09PSAndGFiJztcbiAgICB9KTtcbiAgICBsaXN0ZW5pbmcgPSB0cnVlO1xuICB9XG59XG5cbmNsYXNzIEVuaGFuY2VkQnV0dG9uIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBjZW50ZXJSaXBwbGU6IFByb3BUeXBlcy5ib29sLFxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICBjb250YWluZXJFbGVtZW50OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICAgIFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICBQcm9wVHlwZXMuZWxlbWVudCxcbiAgICBdKSxcbiAgICBkaXNhYmxlRm9jdXNSaXBwbGU6IFByb3BUeXBlcy5ib29sLFxuICAgIGRpc2FibGVLZXlib2FyZEZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBkaXNhYmxlVG91Y2hSaXBwbGU6IFByb3BUeXBlcy5ib29sLFxuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBmb2N1c1JpcHBsZUNvbG9yOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGZvY3VzUmlwcGxlT3BhY2l0eTogUHJvcFR5cGVzLm51bWJlcixcbiAgICBocmVmOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGtleWJvYXJkRm9jdXNlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgb25CbHVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkZvY3VzOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbktleURvd246IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uS2V5VXA6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uS2V5Ym9hcmRGb2N1czogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Nb3VzZURvd246IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uTW91c2VFbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Nb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbk1vdXNlVXA6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uVG91Y2hFbmQ6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uVG91Y2hTdGFydDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Ub3VjaFRhcDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgdGFiSW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgdG91Y2hSaXBwbGVDb2xvcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICB0b3VjaFJpcHBsZU9wYWNpdHk6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgdHlwZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGNvbnRhaW5lckVsZW1lbnQ6ICdidXR0b24nLFxuICAgIG9uQmx1cjogKCkgPT4ge30sXG4gICAgb25DbGljazogKCkgPT4ge30sXG4gICAgb25Gb2N1czogKCkgPT4ge30sXG4gICAgb25LZXlEb3duOiAoKSA9PiB7fSxcbiAgICBvbktleVVwOiAoKSA9PiB7fSxcbiAgICBvbktleWJvYXJkRm9jdXM6ICgpID0+IHt9LFxuICAgIG9uTW91c2VEb3duOiAoKSA9PiB7fSxcbiAgICBvbk1vdXNlRW50ZXI6ICgpID0+IHt9LFxuICAgIG9uTW91c2VMZWF2ZTogKCkgPT4ge30sXG4gICAgb25Nb3VzZVVwOiAoKSA9PiB7fSxcbiAgICBvblRvdWNoRW5kOiAoKSA9PiB7fSxcbiAgICBvblRvdWNoU3RhcnQ6ICgpID0+IHt9LFxuICAgIG9uVG91Y2hUYXA6ICgpID0+IHt9LFxuICAgIHRhYkluZGV4OiAwLFxuICAgIHR5cGU6ICdidXR0b24nLFxuICB9O1xuXG4gIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7XG4gICAgbXVpVGhlbWU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgfTtcblxuICBzdGF0ZSA9IHtpc0tleWJvYXJkRm9jdXNlZDogZmFsc2V9O1xuXG4gIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBjb25zdCB7ZGlzYWJsZWQsIGRpc2FibGVLZXlib2FyZEZvY3VzLCBrZXlib2FyZEZvY3VzZWR9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIWRpc2FibGVkICYmIGtleWJvYXJkRm9jdXNlZCAmJiAhZGlzYWJsZUtleWJvYXJkRm9jdXMpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe2lzS2V5Ym9hcmRGb2N1c2VkOiB0cnVlfSk7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgaW5qZWN0U3R5bGUoKTtcbiAgICBsaXN0ZW5Gb3JUYWJQcmVzc2VzKCk7XG4gICAgaWYgKHRoaXMuc3RhdGUuaXNLZXlib2FyZEZvY3VzZWQpIHtcbiAgICAgIHRoaXMucmVmcy5lbmhhbmNlZEJ1dHRvbi5mb2N1cygpO1xuICAgICAgdGhpcy5wcm9wcy5vbktleWJvYXJkRm9jdXMobnVsbCwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAoKG5leHRQcm9wcy5kaXNhYmxlZCB8fCBuZXh0UHJvcHMuZGlzYWJsZUtleWJvYXJkRm9jdXMpICYmXG4gICAgICB0aGlzLnN0YXRlLmlzS2V5Ym9hcmRGb2N1c2VkKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtpc0tleWJvYXJkRm9jdXNlZDogZmFsc2V9KTtcbiAgICAgIGlmIChuZXh0UHJvcHMub25LZXlib2FyZEZvY3VzKSB7XG4gICAgICAgIG5leHRQcm9wcy5vbktleWJvYXJkRm9jdXMobnVsbCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmZvY3VzVGltZW91dCk7XG4gIH1cblxuICBpc0tleWJvYXJkRm9jdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc0tleWJvYXJkRm9jdXNlZDtcbiAgfVxuXG4gIHJlbW92ZUtleWJvYXJkRm9jdXMoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5pc0tleWJvYXJkRm9jdXNlZCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7aXNLZXlib2FyZEZvY3VzZWQ6IGZhbHNlfSk7XG4gICAgICB0aGlzLnByb3BzLm9uS2V5Ym9hcmRGb2N1cyhldmVudCwgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIHNldEtleWJvYXJkRm9jdXMoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuaXNLZXlib2FyZEZvY3VzZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe2lzS2V5Ym9hcmRGb2N1c2VkOiB0cnVlfSk7XG4gICAgICB0aGlzLnByb3BzLm9uS2V5Ym9hcmRGb2N1cyhldmVudCwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgY2FuY2VsRm9jdXNUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLmZvY3VzVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZm9jdXNUaW1lb3V0KTtcbiAgICAgIHRoaXMuZm9jdXNUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBjcmVhdGVCdXR0b25DaGlsZHJlbigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjZW50ZXJSaXBwbGUsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGRpc2FibGVkLFxuICAgICAgZGlzYWJsZUZvY3VzUmlwcGxlLFxuICAgICAgZGlzYWJsZUtleWJvYXJkRm9jdXMsXG4gICAgICBkaXNhYmxlVG91Y2hSaXBwbGUsXG4gICAgICBmb2N1c1JpcHBsZUNvbG9yLFxuICAgICAgZm9jdXNSaXBwbGVPcGFjaXR5LFxuICAgICAgdG91Y2hSaXBwbGVDb2xvcixcbiAgICAgIHRvdWNoUmlwcGxlT3BhY2l0eSxcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7aXNLZXlib2FyZEZvY3VzZWR9ID0gdGhpcy5zdGF0ZTtcblxuICAgIC8vIEZvY3VzIFJpcHBsZVxuICAgIGNvbnN0IGZvY3VzUmlwcGxlID0gaXNLZXlib2FyZEZvY3VzZWQgJiYgIWRpc2FibGVkICYmICFkaXNhYmxlRm9jdXNSaXBwbGUgJiYgIWRpc2FibGVLZXlib2FyZEZvY3VzID8gKFxuICAgICAgPEZvY3VzUmlwcGxlXG4gICAgICAgIGNvbG9yPXtmb2N1c1JpcHBsZUNvbG9yfVxuICAgICAgICBvcGFjaXR5PXtmb2N1c1JpcHBsZU9wYWNpdHl9XG4gICAgICAgIHNob3c9e2lzS2V5Ym9hcmRGb2N1c2VkfVxuICAgICAgLz5cbiAgICApIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gVG91Y2ggUmlwcGxlXG4gICAgY29uc3QgdG91Y2hSaXBwbGUgPSAhZGlzYWJsZWQgJiYgIWRpc2FibGVUb3VjaFJpcHBsZSA/IChcbiAgICAgIDxUb3VjaFJpcHBsZVxuICAgICAgICBjZW50ZXJSaXBwbGU9e2NlbnRlclJpcHBsZX1cbiAgICAgICAgY29sb3I9e3RvdWNoUmlwcGxlQ29sb3J9XG4gICAgICAgIG9wYWNpdHk9e3RvdWNoUmlwcGxlT3BhY2l0eX1cbiAgICAgID5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9Ub3VjaFJpcHBsZT5cbiAgICApIDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIGNyZWF0ZUNoaWxkRnJhZ21lbnQoe1xuICAgICAgZm9jdXNSaXBwbGUsXG4gICAgICB0b3VjaFJpcHBsZSxcbiAgICAgIGNoaWxkcmVuOiB0b3VjaFJpcHBsZSA/IHVuZGVmaW5lZCA6IGNoaWxkcmVuLFxuICAgIH0pO1xuICB9XG5cbiAgaGFuZGxlS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgIGlmICghdGhpcy5wcm9wcy5kaXNhYmxlZCAmJiAhdGhpcy5wcm9wcy5kaXNhYmxlS2V5Ym9hcmRGb2N1cykge1xuICAgICAgaWYgKGtleWNvZGUoZXZlbnQpID09PSAnZW50ZXInICYmIHRoaXMuc3RhdGUuaXNLZXlib2FyZEZvY3VzZWQpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3VjaFRhcChldmVudCk7XG4gICAgICB9XG4gICAgICBpZiAoa2V5Y29kZShldmVudCkgPT09ICdlc2MnICYmIHRoaXMuc3RhdGUuaXNLZXlib2FyZEZvY3VzZWQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVLZXlib2FyZEZvY3VzKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcm9wcy5vbktleURvd24oZXZlbnQpO1xuICB9O1xuXG4gIGhhbmRsZUtleVVwID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKCF0aGlzLnByb3BzLmRpc2FibGVkICYmICF0aGlzLnByb3BzLmRpc2FibGVLZXlib2FyZEZvY3VzKSB7XG4gICAgICBpZiAoa2V5Y29kZShldmVudCkgPT09ICdzcGFjZScgJiYgdGhpcy5zdGF0ZS5pc0tleWJvYXJkRm9jdXNlZCkge1xuICAgICAgICB0aGlzLmhhbmRsZVRvdWNoVGFwKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcm9wcy5vbktleVVwKGV2ZW50KTtcbiAgfTtcblxuICBoYW5kbGVCbHVyID0gKGV2ZW50KSA9PiB7XG4gICAgdGhpcy5jYW5jZWxGb2N1c1RpbWVvdXQoKTtcbiAgICB0aGlzLnJlbW92ZUtleWJvYXJkRm9jdXMoZXZlbnQpO1xuICAgIHRoaXMucHJvcHMub25CbHVyKGV2ZW50KTtcbiAgfTtcblxuICBoYW5kbGVGb2N1cyA9IChldmVudCkgPT4ge1xuICAgIGlmIChldmVudCkgZXZlbnQucGVyc2lzdCgpO1xuICAgIGlmICghdGhpcy5wcm9wcy5kaXNhYmxlZCAmJiAhdGhpcy5wcm9wcy5kaXNhYmxlS2V5Ym9hcmRGb2N1cykge1xuICAgICAgLy8gc2V0VGltZW91dCBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgZm9jdXMgZXZlbnQgZmlyZXMgZmlyc3RcbiAgICAgIC8vIFdhaXQgc28gdGhhdCB3ZSBjYW4gY2FwdHVyZSBpZiB0aGlzIHdhcyBhIGtleWJvYXJkIGZvY3VzXG4gICAgICAvLyBvciB0b3VjaCBmb2N1c1xuICAgICAgdGhpcy5mb2N1c1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHRhYlByZXNzZWQpIHtcbiAgICAgICAgICB0aGlzLnNldEtleWJvYXJkRm9jdXMoZXZlbnQpO1xuICAgICAgICAgIHRhYlByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSwgMTUwKTtcblxuICAgICAgdGhpcy5wcm9wcy5vbkZvY3VzKGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICBpZiAoIXRoaXMucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHRhYlByZXNzZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucHJvcHMub25DbGljayhldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZVRvdWNoVGFwID0gKGV2ZW50KSA9PiB7XG4gICAgdGhpcy5jYW5jZWxGb2N1c1RpbWVvdXQoKTtcbiAgICBpZiAoIXRoaXMucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHRhYlByZXNzZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucmVtb3ZlS2V5Ym9hcmRGb2N1cyhldmVudCk7XG4gICAgICB0aGlzLnByb3BzLm9uVG91Y2hUYXAoZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2VudGVyUmlwcGxlLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGNvbnRhaW5lckVsZW1lbnQsXG4gICAgICBkaXNhYmxlZCxcbiAgICAgIGRpc2FibGVGb2N1c1JpcHBsZSxcbiAgICAgIGRpc2FibGVLZXlib2FyZEZvY3VzLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBkaXNhYmxlVG91Y2hSaXBwbGUsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIGZvY3VzUmlwcGxlQ29sb3IsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIGZvY3VzUmlwcGxlT3BhY2l0eSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgaHJlZixcbiAgICAgIGtleWJvYXJkRm9jdXNlZCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgdG91Y2hSaXBwbGVDb2xvciwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgdG91Y2hSaXBwbGVPcGFjaXR5LCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBvbkJsdXIsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIG9uQ2xpY2ssIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIG9uRm9jdXMsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIG9uS2V5VXAsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIG9uS2V5RG93biwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgb25LZXlib2FyZEZvY3VzLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBvblRvdWNoVGFwLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBzdHlsZSxcbiAgICAgIHRhYkluZGV4LFxuICAgICAgdHlwZSxcbiAgICAgIC4uLm90aGVyXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCB7XG4gICAgICBwcmVwYXJlU3R5bGVzLFxuICAgICAgZW5oYW5jZWRCdXR0b24sXG4gICAgfSA9IHRoaXMuY29udGV4dC5tdWlUaGVtZTtcblxuICAgIGNvbnN0IG1lcmdlZFN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgYm9yZGVyOiAxMCxcbiAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBmb250RmFtaWx5OiB0aGlzLmNvbnRleHQubXVpVGhlbWUuYmFzZVRoZW1lLmZvbnRGYW1pbHksXG4gICAgICBXZWJraXRUYXBIaWdobGlnaHRDb2xvcjogZW5oYW5jZWRCdXR0b24udGFwSGlnaGxpZ2h0Q29sb3IsIC8vIFJlbW92ZSBtb2JpbGUgY29sb3IgZmxhc2hpbmcgKGRlcHJlY2F0ZWQpXG4gICAgICBjdXJzb3I6IGRpc2FibGVkID8gJ2RlZmF1bHQnIDogJ3BvaW50ZXInLFxuICAgICAgdGV4dERlY29yYXRpb246ICdub25lJyxcbiAgICAgIG1hcmdpbjogMCxcbiAgICAgIHBhZGRpbmc6IDAsXG4gICAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgICBmb250U2l6ZTogJ2luaGVyaXQnLFxuICAgICAgZm9udFdlaWdodDogJ2luaGVyaXQnLFxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGlzIG5lZWRlZCBzbyB0aGF0IHJpcHBsZXMgZG8gbm90IGJsZWVkXG4gICAgICAgKiBwYXN0IGJvcmRlciByYWRpdXMuXG4gICAgICAgKiBTZWU6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTcyOTg3MzkvXG4gICAgICAgKiBjc3Mtb3ZlcmZsb3ctaGlkZGVuLW5vdC13b3JraW5nLWluLWNocm9tZS13aGVuLXBhcmVudC1oYXMtYm9yZGVyLXJhZGl1cy1hbmQtY2hpbFxuICAgICAgICovXG4gICAgICB0cmFuc2Zvcm06IGRpc2FibGVUb3VjaFJpcHBsZSAmJiBkaXNhYmxlRm9jdXNSaXBwbGUgPyBudWxsIDogJ3RyYW5zbGF0ZSgwLCAwKScsXG4gICAgICB2ZXJ0aWNhbEFsaWduOiBocmVmID8gJ21pZGRsZScgOiBudWxsLFxuICAgIH0sIHN0eWxlKTtcblxuXG4gICAgLy8gUGFzc2luZyBib3RoIGJhY2tncm91bmQ6bm9uZSAmIGJhY2tncm91bmRDb2xvciBjYW4gYnJlYWsgZHVlIHRvIG9iamVjdCBpdGVyYXRpb24gb3JkZXJcbiAgICBpZiAoIW1lcmdlZFN0eWxlcy5iYWNrZ3JvdW5kQ29sb3IgJiYgIW1lcmdlZFN0eWxlcy5iYWNrZ3JvdW5kKSB7XG4gICAgICBtZXJnZWRTdHlsZXMuYmFja2dyb3VuZCA9ICdub25lJztcbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWQgJiYgaHJlZikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPHNwYW5cbiAgICAgICAgICB7Li4ub3RoZXJ9XG4gICAgICAgICAgc3R5bGU9e21lcmdlZFN0eWxlc31cbiAgICAgICAgPlxuICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9zcGFuPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBidXR0b25Qcm9wcyA9IHtcbiAgICAgIC4uLm90aGVyLFxuICAgICAgc3R5bGU6IHByZXBhcmVTdHlsZXMobWVyZ2VkU3R5bGVzKSxcbiAgICAgIHJlZjogJ2VuaGFuY2VkQnV0dG9uJyxcbiAgICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICAgIGhyZWY6IGhyZWYsXG4gICAgICBvbkJsdXI6IHRoaXMuaGFuZGxlQmx1cixcbiAgICAgIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2xpY2ssXG4gICAgICBvbkZvY3VzOiB0aGlzLmhhbmRsZUZvY3VzLFxuICAgICAgb25LZXlVcDogdGhpcy5oYW5kbGVLZXlVcCxcbiAgICAgIG9uS2V5RG93bjogdGhpcy5oYW5kbGVLZXlEb3duLFxuICAgICAgb25Ub3VjaFRhcDogdGhpcy5oYW5kbGVUb3VjaFRhcCxcbiAgICAgIHRhYkluZGV4OiBkaXNhYmxlZCB8fCBkaXNhYmxlS2V5Ym9hcmRGb2N1cyA/IC0xIDogdGFiSW5kZXgsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgIH07XG4gICAgY29uc3QgYnV0dG9uQ2hpbGRyZW4gPSB0aGlzLmNyZWF0ZUJ1dHRvbkNoaWxkcmVuKCk7XG5cbiAgICBpZiAoUmVhY3QuaXNWYWxpZEVsZW1lbnQoY29udGFpbmVyRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY29udGFpbmVyRWxlbWVudCwgYnV0dG9uUHJvcHMsIGJ1dHRvbkNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChocmVmID8gJ2EnIDogY29udGFpbmVyRWxlbWVudCwgYnV0dG9uUHJvcHMsIGJ1dHRvbkNoaWxkcmVuKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFbmhhbmNlZEJ1dHRvbjtcbiJdfQ==