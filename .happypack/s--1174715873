'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _transitions = require('../styles/transitions');

var _transitions2 = _interopRequireDefault(_transitions);

var _SlideIn = require('../internal/SlideIn');

var _SlideIn2 = _interopRequireDefault(_SlideIn);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function getStyles(props, context, state) {
  var datePicker = context.muiTheme.datePicker;
  var selectedYear = state.selectedYear;

  var isLandscape = props.mode === 'landscape';

  var styles = {
    root: {
      width: isLandscape ? 165 : '100%',
      height: isLandscape ? 330 : 'auto',
      float: isLandscape ? 'left' : 'none',
      fontWeight: 700,
      display: 'inline-block',
      backgroundColor: datePicker.selectColor,
      borderTopLeftRadius: 2,
      borderTopRightRadius: isLandscape ? 0 : 2,
      borderBottomLeftRadius: isLandscape ? 2 : 0,
      color: datePicker.textColor,
      padding: 20,
      boxSizing: 'border-box'
    },
    monthDay: {
      display: 'block',
      fontSize: 36,
      lineHeight: '36px',
      height: props.mode === 'landscape' ? '100%' : 38,
      opacity: selectedYear ? 0.7 : 1,
      transition: _transitions2.default.easeOut(),
      width: '100%',
      fontWeight: '500'
    },
    monthDayTitle: {
      cursor: !selectedYear ? 'default' : 'pointer',
      width: '100%',
      display: 'block'
    },
    year: {
      margin: 0,
      fontSize: 16,
      fontWeight: '500',
      lineHeight: '16px',
      height: 16,
      opacity: selectedYear ? 1 : 0.7,
      transition: _transitions2.default.easeOut(),
      marginBottom: 10
    },
    yearTitle: {
      cursor: props.disableYearSelection ? 'not-allowed' : !selectedYear ? 'pointer' : 'default'
    }
  };

  return styles;
}

var DateDisplay = function (_Component) {
  _inherits(DateDisplay, _Component);

  function DateDisplay() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, DateDisplay);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = DateDisplay.__proto__ || Object.getPrototypeOf(DateDisplay)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      selectedYear: false,
      transitionDirection: 'up'
    }, _this.handleTouchTapMonthDay = function () {
      if (_this.props.onTouchTapMonthDay && _this.state.selectedYear) {
        _this.props.onTouchTapMonthDay();
      }

      _this.setState({ selectedYear: false });
    }, _this.handleTouchTapYear = function () {
      if (_this.props.onTouchTapYear && !_this.props.disableYearSelection && !_this.state.selectedYear) {
        _this.props.onTouchTapYear();
      }

      if (!_this.props.disableYearSelection) {
        _this.setState({ selectedYear: true });
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(DateDisplay, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      if (!this.props.monthDaySelected) {
        this.setState({ selectedYear: true });
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.selectedDate !== this.props.selectedDate) {
        var direction = nextProps.selectedDate > this.props.selectedDate ? 'up' : 'down';
        this.setState({
          transitionDirection: direction
        });
      }

      if (nextProps.monthDaySelected !== undefined) {
        this.setState({
          selectedYear: !nextProps.monthDaySelected
        });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          DateTimeFormat = _props.DateTimeFormat,
          disableYearSelection = _props.disableYearSelection,
          locale = _props.locale,
          mode = _props.mode,
          monthDaySelected = _props.monthDaySelected,
          onTouchTapMonthDay = _props.onTouchTapMonthDay,
          onTouchTapYear = _props.onTouchTapYear,
          selectedDate = _props.selectedDate,
          style = _props.style,
          other = _objectWithoutProperties(_props, ['DateTimeFormat', 'disableYearSelection', 'locale', 'mode', 'monthDaySelected', 'onTouchTapMonthDay', 'onTouchTapYear', 'selectedDate', 'style']);

      var prepareStyles = this.context.muiTheme.prepareStyles;

      var styles = getStyles(this.props, this.context, this.state);

      var year = new DateTimeFormat(locale, {
        year: 'numeric'
      }).format(selectedDate);

      var dateTime = new DateTimeFormat(locale, {
        month: 'short',
        weekday: 'short',
        day: '2-digit'
      }).format(selectedDate);

      return _react2.default.createElement(
        'div',
        _extends({}, other, { style: prepareStyles(styles.root, style) }),
        _react2.default.createElement(
          _SlideIn2.default,
          { style: styles.year, direction: this.state.transitionDirection },
          _react2.default.createElement(
            'div',
            { key: year, style: styles.yearTitle, onTouchTap: this.handleTouchTapYear },
            year
          )
        ),
        _react2.default.createElement(
          _SlideIn2.default,
          { style: styles.monthDay, direction: this.state.transitionDirection },
          _react2.default.createElement(
            'div',
            {
              key: dateTime,
              onTouchTap: this.handleTouchTapMonthDay,
              style: styles.monthDayTitle
            },
            dateTime
          )
        )
      );
    }
  }]);

  return DateDisplay;
}(_react.Component);

DateDisplay.propTypes = {
  DateTimeFormat: _react.PropTypes.func.isRequired,
  disableYearSelection: _react.PropTypes.bool,
  locale: _react.PropTypes.string.isRequired,
  mode: _react.PropTypes.oneOf(['portrait', 'landscape']),
  monthDaySelected: _react.PropTypes.bool,
  onTouchTapMonthDay: _react.PropTypes.func,
  onTouchTapYear: _react.PropTypes.func,
  selectedDate: _react.PropTypes.object.isRequired,
  style: _react.PropTypes.object
};
DateDisplay.defaultProps = {
  disableYearSelection: false,
  monthDaySelected: true
};
DateDisplay.contextTypes = {
  muiTheme: _react.PropTypes.object.isRequired
};
var _default = DateDisplay;
exports.default = _default;
;

var _temp2 = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(getStyles, 'getStyles', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/DatePicker/DateDisplay.js');

  __REACT_HOT_LOADER__.register(DateDisplay, 'DateDisplay', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/DatePicker/DateDisplay.js');

  __REACT_HOT_LOADER__.register(_default, 'default', '/Users/tmac_zc/Code/kr-admin/src/Components/DatePicker/DatePicker/DateDisplay.js');
}();

;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9Db21wb25lbnRzL0RhdGVQaWNrZXIvRGF0ZVBpY2tlci9EYXRlRGlzcGxheS5qcyJdLCJuYW1lcyI6WyJnZXRTdHlsZXMiLCJwcm9wcyIsImNvbnRleHQiLCJzdGF0ZSIsImRhdGVQaWNrZXIiLCJtdWlUaGVtZSIsInNlbGVjdGVkWWVhciIsImlzTGFuZHNjYXBlIiwibW9kZSIsInN0eWxlcyIsInJvb3QiLCJ3aWR0aCIsImhlaWdodCIsImZsb2F0IiwiZm9udFdlaWdodCIsImRpc3BsYXkiLCJiYWNrZ3JvdW5kQ29sb3IiLCJzZWxlY3RDb2xvciIsImJvcmRlclRvcExlZnRSYWRpdXMiLCJib3JkZXJUb3BSaWdodFJhZGl1cyIsImJvcmRlckJvdHRvbUxlZnRSYWRpdXMiLCJjb2xvciIsInRleHRDb2xvciIsInBhZGRpbmciLCJib3hTaXppbmciLCJtb250aERheSIsImZvbnRTaXplIiwibGluZUhlaWdodCIsIm9wYWNpdHkiLCJ0cmFuc2l0aW9uIiwiZWFzZU91dCIsIm1vbnRoRGF5VGl0bGUiLCJjdXJzb3IiLCJ5ZWFyIiwibWFyZ2luIiwibWFyZ2luQm90dG9tIiwieWVhclRpdGxlIiwiZGlzYWJsZVllYXJTZWxlY3Rpb24iLCJEYXRlRGlzcGxheSIsInRyYW5zaXRpb25EaXJlY3Rpb24iLCJoYW5kbGVUb3VjaFRhcE1vbnRoRGF5Iiwib25Ub3VjaFRhcE1vbnRoRGF5Iiwic2V0U3RhdGUiLCJoYW5kbGVUb3VjaFRhcFllYXIiLCJvblRvdWNoVGFwWWVhciIsIm1vbnRoRGF5U2VsZWN0ZWQiLCJuZXh0UHJvcHMiLCJzZWxlY3RlZERhdGUiLCJkaXJlY3Rpb24iLCJ1bmRlZmluZWQiLCJEYXRlVGltZUZvcm1hdCIsImxvY2FsZSIsInN0eWxlIiwib3RoZXIiLCJwcmVwYXJlU3R5bGVzIiwiZm9ybWF0IiwiZGF0ZVRpbWUiLCJtb250aCIsIndlZWtkYXkiLCJkYXkiLCJwcm9wVHlwZXMiLCJmdW5jIiwiaXNSZXF1aXJlZCIsImJvb2wiLCJzdHJp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QnRCLHNCQUFvQixpQkFBVW9CLElBTmI7QUFPakJqQixrQkFBZ0IsaUJBQVVpQixJQVBUO0FBUWpCZCxnQkFBYyxpQkFBVW1CLE1BQVYsQ0FBaUJKLFVBUmQ7QUFTakJWLFNBQU8saUJBQVVjO0FBVEEsQztBQURmNUIsVyxDQWFHNkIsWSxHQUFlO0FBQ3BCOUIsd0JBQXNCLEtBREY7QUFFcEJRLG9CQUFrQjtBQUZFLEM7QUFibEJQLFcsQ0FrQkc4QixZLEdBQWU7QUFDcEIvRCxZQUFVLGlCQUFVNkQsTUFBVixDQUFpQko7QUFEUCxDO2VBaUdUeEIsVzs7Ozs7Ozs7O2dDQXhLTnRDLFM7O2dDQXFESHNDLFciLCJmaWxlIjoiRGF0ZURpc3BsYXkuanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL3RtYWNfemMvQ29kZS9rci1hZG1pbiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwge0NvbXBvbmVudCwgUHJvcFR5cGVzfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdHJhbnNpdGlvbnMgZnJvbSAnLi4vc3R5bGVzL3RyYW5zaXRpb25zJztcbmltcG9ydCBTbGlkZUluVHJhbnNpdGlvbkdyb3VwIGZyb20gJy4uL2ludGVybmFsL1NsaWRlSW4nO1xuXG5mdW5jdGlvbiBnZXRTdHlsZXMocHJvcHMsIGNvbnRleHQsIHN0YXRlKSB7XG4gIGNvbnN0IHtkYXRlUGlja2VyfSA9IGNvbnRleHQubXVpVGhlbWU7XG4gIGNvbnN0IHtzZWxlY3RlZFllYXJ9ID0gc3RhdGU7XG4gIGNvbnN0IGlzTGFuZHNjYXBlID0gcHJvcHMubW9kZSA9PT0gJ2xhbmRzY2FwZSc7XG5cbiAgY29uc3Qgc3R5bGVzID0ge1xuICAgIHJvb3Q6IHtcbiAgICAgIHdpZHRoOiBpc0xhbmRzY2FwZSA/IDE2NSA6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogaXNMYW5kc2NhcGUgPyAzMzAgOiAnYXV0bycsXG4gICAgICBmbG9hdDogaXNMYW5kc2NhcGUgPyAnbGVmdCcgOiAnbm9uZScsXG4gICAgICBmb250V2VpZ2h0OiA3MDAsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogZGF0ZVBpY2tlci5zZWxlY3RDb2xvcixcbiAgICAgIGJvcmRlclRvcExlZnRSYWRpdXM6IDIsXG4gICAgICBib3JkZXJUb3BSaWdodFJhZGl1czogaXNMYW5kc2NhcGUgPyAwIDogMixcbiAgICAgIGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6IGlzTGFuZHNjYXBlID8gMiA6IDAsXG4gICAgICBjb2xvcjogZGF0ZVBpY2tlci50ZXh0Q29sb3IsXG4gICAgICBwYWRkaW5nOiAyMCxcbiAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIH0sXG4gICAgbW9udGhEYXk6IHtcbiAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICBmb250U2l6ZTogMzYsXG4gICAgICBsaW5lSGVpZ2h0OiAnMzZweCcsXG4gICAgICBoZWlnaHQ6IHByb3BzLm1vZGUgPT09ICdsYW5kc2NhcGUnID8gJzEwMCUnIDogMzgsXG4gICAgICBvcGFjaXR5OiBzZWxlY3RlZFllYXIgPyAwLjcgOiAxLFxuICAgICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbnMuZWFzZU91dCgpLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGZvbnRXZWlnaHQ6ICc1MDAnLFxuICAgIH0sXG4gICAgbW9udGhEYXlUaXRsZToge1xuICAgICAgY3Vyc29yOiAhc2VsZWN0ZWRZZWFyID8gJ2RlZmF1bHQnIDogJ3BvaW50ZXInLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgfSxcbiAgICB5ZWFyOiB7XG4gICAgICBtYXJnaW46IDAsXG4gICAgICBmb250U2l6ZTogMTYsXG4gICAgICBmb250V2VpZ2h0OiAnNTAwJyxcbiAgICAgIGxpbmVIZWlnaHQ6ICcxNnB4JyxcbiAgICAgIGhlaWdodDogMTYsXG4gICAgICBvcGFjaXR5OiBzZWxlY3RlZFllYXIgPyAxIDogMC43LFxuICAgICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbnMuZWFzZU91dCgpLFxuICAgICAgbWFyZ2luQm90dG9tOiAxMCxcbiAgICB9LFxuICAgIHllYXJUaXRsZToge1xuICAgICAgY3Vyc29yOiBwcm9wcy5kaXNhYmxlWWVhclNlbGVjdGlvbiA/ICdub3QtYWxsb3dlZCcgOiAoIXNlbGVjdGVkWWVhciA/ICdwb2ludGVyJyA6ICdkZWZhdWx0JyksXG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gc3R5bGVzO1xufVxuXG5jbGFzcyBEYXRlRGlzcGxheSBleHRlbmRzIENvbXBvbmVudCB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgRGF0ZVRpbWVGb3JtYXQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZGlzYWJsZVllYXJTZWxlY3Rpb246IFByb3BUeXBlcy5ib29sLFxuICAgIGxvY2FsZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIG1vZGU6IFByb3BUeXBlcy5vbmVPZihbJ3BvcnRyYWl0JywgJ2xhbmRzY2FwZSddKSxcbiAgICBtb250aERheVNlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBvblRvdWNoVGFwTW9udGhEYXk6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uVG91Y2hUYXBZZWFyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBzZWxlY3RlZERhdGU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGRpc2FibGVZZWFyU2VsZWN0aW9uOiBmYWxzZSxcbiAgICBtb250aERheVNlbGVjdGVkOiB0cnVlLFxuICB9O1xuXG4gIHN0YXRpYyBjb250ZXh0VHlwZXMgPSB7XG4gICAgbXVpVGhlbWU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgfTtcblxuICBzdGF0ZSA9IHtcbiAgICBzZWxlY3RlZFllYXI6IGZhbHNlLFxuICAgIHRyYW5zaXRpb25EaXJlY3Rpb246ICd1cCcsXG4gIH07XG5cbiAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIGlmICghdGhpcy5wcm9wcy5tb250aERheVNlbGVjdGVkKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtzZWxlY3RlZFllYXI6IHRydWV9KTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMuc2VsZWN0ZWREYXRlICE9PSB0aGlzLnByb3BzLnNlbGVjdGVkRGF0ZSkge1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gbmV4dFByb3BzLnNlbGVjdGVkRGF0ZSA+IHRoaXMucHJvcHMuc2VsZWN0ZWREYXRlID8gJ3VwJyA6ICdkb3duJztcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICB0cmFuc2l0aW9uRGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobmV4dFByb3BzLm1vbnRoRGF5U2VsZWN0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHNlbGVjdGVkWWVhcjogIW5leHRQcm9wcy5tb250aERheVNlbGVjdGVkLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlVG91Y2hUYXBNb250aERheSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5wcm9wcy5vblRvdWNoVGFwTW9udGhEYXkgJiYgdGhpcy5zdGF0ZS5zZWxlY3RlZFllYXIpIHtcbiAgICAgIHRoaXMucHJvcHMub25Ub3VjaFRhcE1vbnRoRGF5KCk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7c2VsZWN0ZWRZZWFyOiBmYWxzZX0pO1xuICB9O1xuXG4gIGhhbmRsZVRvdWNoVGFwWWVhciA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5wcm9wcy5vblRvdWNoVGFwWWVhciAmJiAhdGhpcy5wcm9wcy5kaXNhYmxlWWVhclNlbGVjdGlvbiAmJiAhdGhpcy5zdGF0ZS5zZWxlY3RlZFllYXIpIHtcbiAgICAgIHRoaXMucHJvcHMub25Ub3VjaFRhcFllYXIoKTtcblxuICAgIH1cblxuICAgIGlmICghdGhpcy5wcm9wcy5kaXNhYmxlWWVhclNlbGVjdGlvbikge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7c2VsZWN0ZWRZZWFyOiB0cnVlfSk7XG4gICAgfVxuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBEYXRlVGltZUZvcm1hdCxcbiAgICAgIGRpc2FibGVZZWFyU2VsZWN0aW9uLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBsb2NhbGUsXG4gICAgICBtb2RlLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBtb250aERheVNlbGVjdGVkLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBvblRvdWNoVGFwTW9udGhEYXksIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIG9uVG91Y2hUYXBZZWFyLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBzZWxlY3RlZERhdGUsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHN0eWxlLFxuICAgICAgLi4ub3RoZXJcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IHtwcmVwYXJlU3R5bGVzfSA9IHRoaXMuY29udGV4dC5tdWlUaGVtZTtcbiAgICBjb25zdCBzdHlsZXMgPSBnZXRTdHlsZXModGhpcy5wcm9wcywgdGhpcy5jb250ZXh0LCB0aGlzLnN0YXRlKTtcblxuICAgIGNvbnN0IHllYXIgPSBuZXcgRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCB7XG4gICAgICB5ZWFyOiAnbnVtZXJpYycsXG4gICAgfSkuZm9ybWF0KHNlbGVjdGVkRGF0ZSk7XG5cbiAgICBjb25zdCBkYXRlVGltZSA9IG5ldyBEYXRlVGltZUZvcm1hdChsb2NhbGUsIHtcbiAgICAgIG1vbnRoOiAnc2hvcnQnLFxuICAgICAgd2Vla2RheTogJ3Nob3J0JyxcbiAgICAgIGRheTogJzItZGlnaXQnLFxuICAgIH0pLmZvcm1hdChzZWxlY3RlZERhdGUpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgey4uLm90aGVyfSBzdHlsZT17cHJlcGFyZVN0eWxlcyhzdHlsZXMucm9vdCwgc3R5bGUpfT5cbiAgICAgICAgPFNsaWRlSW5UcmFuc2l0aW9uR3JvdXAgc3R5bGU9e3N0eWxlcy55ZWFyfSBkaXJlY3Rpb249e3RoaXMuc3RhdGUudHJhbnNpdGlvbkRpcmVjdGlvbn0+XG4gICAgICAgICAgPGRpdiBrZXk9e3llYXJ9IHN0eWxlPXtzdHlsZXMueWVhclRpdGxlfSBvblRvdWNoVGFwPXt0aGlzLmhhbmRsZVRvdWNoVGFwWWVhcn0+XG4gICAgICAgICAgICB7eWVhcn1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9TbGlkZUluVHJhbnNpdGlvbkdyb3VwPlxuICAgICAgICA8U2xpZGVJblRyYW5zaXRpb25Hcm91cCBzdHlsZT17c3R5bGVzLm1vbnRoRGF5fSBkaXJlY3Rpb249e3RoaXMuc3RhdGUudHJhbnNpdGlvbkRpcmVjdGlvbn0+XG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAga2V5PXtkYXRlVGltZX1cbiAgICAgICAgICAgIG9uVG91Y2hUYXA9e3RoaXMuaGFuZGxlVG91Y2hUYXBNb250aERheX1cbiAgICAgICAgICAgIHN0eWxlPXtzdHlsZXMubW9udGhEYXlUaXRsZX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7ZGF0ZVRpbWV9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvU2xpZGVJblRyYW5zaXRpb25Hcm91cD5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGF0ZURpc3BsYXk7XG4iXX0=